{"pages":[{"title":"books","text":"","link":"/books/"},{"title":"Category","text":"","link":"/categories/"},{"title":"METAL HUNTER","text":"back to gallery","link":"/gallery/horizon"},{"title":"About","text":"","link":"/about/"},{"title":"Tag","text":"","link":"/tags/"},{"title":"Repositories","text":"","link":"/repository/"},{"title":"Gallery 画廊","text":"🎮 机械猎人 《Horizon: Zero Dawn》游戏剪影 原始世界里活跃的”机械生命体“，古奥森然的前人类文明遗迹，冷兵器碰撞上机甲护板摩擦出的层层火花，Zero Dawn 这款游戏带给了我太多太多的视觉享受和战斗趣味。没落的世界碰撞上遗留的机械体，造就出一座幻想殿堂，让人不由自主地穿梭其中，流连忘返。 view more 🖊米山舞のペン 画师：米山舞 关键词：少女与潮服","link":"/gallery/"},{"title":"share","text":"","link":"/share/"}],"posts":[{"title":"技术&#x2F;笔记&#x2F;Talent Plan 项目笔记","text":"Project TinyKV Project 1 [x] 熟悉整个 tinykv 的框架 一个 TinyKv Node 从高到低分三层：Server、Storage、Engine，此外还加上一个 TinyScheduler 组件负责管理 TinyKv 集群 TinySQL 在此次项目中无需实现，值得注意的是 TinySQL 是通过 远端调用 RPC 的方式使用 TinyKv 的 Server 层的接受远程请求，依此调用 Storage 层来提供存取服务 Raw API 提供基本的 GET、PUT、DELETE、SCAN 服务 Txn API 提供事务支持 Coproceccor Transaction MVCC 提供多版本管理服务 Storage 层在 Engine 层的基础上实现 raft 分布式存储 （单机存储引擎 StandAloneStorage 不需要实现 raft，只是单纯的封装Engine 层） Engine 层为最底层，提供基本的键值存储引擎服务（项目中直接使用 badger 作为存储引擎） [x] 了解 raft 算法基本原理 [x] 熟悉 badger api 和 tinykv 项目模板提供的 engine_util 包 [x] 实现 Storage 层的单机存储引擎 StandAloneStorage badger 的只读事务会使用到存储快照，保证了批量读取的一致性（读到的是同一时间点的快照），因此读取操作均借助 badger 事务 badger.Txn 来实现 列族 Column Family，相当于 key 的名称空间，Storage 需要在 Engine 层的基础上封装对列族的支持（存取操作都要指定 列族 CF） [x] 实现 Server 层的 Raw API [ ] 存储引擎相关：LSM-Tree [ ] 序列化与远程过程调用相关：ProtoBuffer &amp; gRPC 参考文献 Raft 基本介绍与可视化：Raft Consensus Algorithm TinyKv 和 TiKv很像，因此可以参考：三篇文章了解 TiDB 技术内幕 - 说存储 | PingCAP badger package 网课： https://learn.pingcap.com/learner/course/510001 Project 2 2A Raft 算法 主要是处理各种情况下的 Message 如何处理 Message ？按优先级参考以下来源： 测试函数 （最具体） doc.go （大体思路） raft 论文 （学习思想、关乎安全性的设计） 对于某些特殊情况可以考虑用 raft 官网上的交互式系统（Raft Visualization）模拟出相应情形加深理解 调用关系图 RaftLog：实现了一个日志，包含对日志的一系列增删查改的操作 Raft：实现 raft 算法，tick() 时钟步进，step() 处理信号（本地消息直接step，msg中的消息是要发送的消息） RawNode：在 Raft 基础上进一步封装，方便上层应用调用（ready，advance） flowchart LR RaftLog --> Raft --> RawNode 关于空日志 noop entry 的定义 123if m.MsgType != pb.MessageType_MsgAppend || len(m.Entries) != 1 || m.Entries[0].Data != nil { panic(\"not a message to append noop entry\")} //noop entry 指代 Data 字段为 nil 的 Entry 注意集群中只有单个节点的情况（此时无需广播append消息、选举直接晋升leader无需广播reqVote等等） 过半否决：Candidate 发起一次投票后如果收到了半数 Reject 则直接变为 Follower，因此要在 Raft 结构体中新增相应的字段记录一轮投票中的否决票数 关于过半 Commit ：可以在每次收到 AppendResponse 之后按照 Prs 大小从低到高排序，然后取中间值 Commit（过半以上的节点至少复制到了该索引值以前的日志） heartbeat和append的区别 heartbeat 间隔一定周期主动发送 维持节点间的主从关系 被动同步：从节点接受到主节点的心跳后发现日志并不同步于是通过HeartbeatResponse反映给主节点让其发起appendEntries同步日志 appendEntries 主动同步：主节点在 propose entries （新增日志）后主动发送直到从节点同步为止 2ac中，ready中的条目是相较于上次调用ready的“更新”的内容，因此需要保存过去的HardState和SoftState的副本，以便比较当前HS和SS是否是有所变化，如果没有变化则置为默认初始值（而不是一股脑地赋值为当前raft的state） 2B Raft Storage 主要内容：驱动Raft模块服务各种Requast并返回Response。 大致思路：接受客户请求，分发请求到对应Region的Leader，包装请求成为raftlog并驱动Leader发起Propose，等待日志一致（commited）后对节点的一些数据持久化（raftlog，applyindex，hardstate等），然后将已经提交的raftlog应用到状态机，最后返回响应，驱动raft模块进行下一步处理（RawNode.advance()） 代码框架 raft_server.go：前端，对外提供访存接口，对内发送请求 transport.go 对外发送消息的接口，面向整个raft集群 raftstore.go：后端，管理peer节点，启动worker，接收来自前端的请求，分发到对应peer peer.go peer_storage.go 管理peer的存储引擎（分为kvDB和raftDB，kvDB相当于raft论文描述的状态机，raftDB存储raft模块里需要持久化的数据方便重启恢复数据） peer_msg_handler.go 处理来自上层的请求 xxxworker.go 各种worker的实现 raft_worker.go raftstore 中实现了接收、分发、处理消息的线程 router.go node/store 内部消息路由，面向单个raft节点 ticker.go 计时模块 注意事项 应用committedEntry的时候需要将appliedState以及Put、Delete等写入操作对KVDB的修改写到同一个WriteBatch中，然后一起writeToDB，以保证原子性（防止apply异常而appliedIndex更新导致的不一致性） Snap Request 要求返回一个Transaction用于读取数据，同样也是为了保证读取的数据时间上的一致性 raft_server.go中似乎没有包装过Get类型的Request，但是测试函数里会发送Get Request。GetResponse中的Value也应当来自于同一个Transaction保证一致性 持久化时写入database的key值要遵循下表的格式 可以采用meta包中的工具函数将region_id&amp;log_idx转化为对应的key Key KeyFormat Value DB raft_log_key 0x01 0x02 region_id 0x01 log_idx Entry raft raft_state_key 0x01 0x02 region_id 0x02 RaftLocalState raft apply_state_key 0x01 0x02 region_id 0x03 RaftApplyState kv region_state_key 0x01 0x03 region_id 0x01 RegionLocalState kv 2C Snapshot &amp; LogCompact 日志压缩 LogCompact RaftGCLogTick 定时检查日志长度，超过一定长度后会发出一个CompactLog的AdminRequest（注意这种request也是要作为日志复制到集群中其他节点并进行commit后才能应用到状态机），store 处理该request的过程实际上就是截断日志链进行压缩，此过程包括修改applyState和raftState等元数据以及通过ScheduleCompactLog托付给raftlog-gc worker将被截断的entries进行删除。以上过程均发生在store层次。 除了store要进行日志压缩外，raft模块中的entry也不能无限增长，需要实现raft.raftlog中的maybeCompact函数对raft模块的日志链进行截断。maybeCompact在Advance时调用。 快照发送 Snapshot 发送：当Leader需要发送已经被截断的日志时（SendAppendEntry），由于此部分日志已经不存在了，所以 leader 需要通过storage.Snapshot获取状态机的快照（快照的具体构建和发送逻辑不需要我们来实现）并发送给目标节点 接受：store层面，节点要判断ready中是否有待处理的快照（即snapshot字段是否为空），如果有则应用该快照（交付给regionWorker处理）并修改元数据","link":"/posts/47eaa8c7/"},{"title":"技术&#x2F;语言&#x2F;C++入门课","text":"C/C++ 课程笔记 绪论 面向对象 面向对象的核心： 封装、继承、多态、 面向对象程序设计的四个阶段 系统分析、系统设计、对象设计和对象实现 编译技术 编译过程： 预处理 词法分析：产生一个程序的单词序列 语法分析：检查程序语法结构 代码生成：生成中间代码 模块连接：中间代码与库连接，形成一个可执行的程序 静态链接 &amp; 动态链接：代码与函数库的连接方式 静态绑定 &amp; 动态绑定：计算函数入口地址的方式 C++基础 重点：const、引用类型 强类型 为所有变量指定数据类型 先声明后使用 不同类型的变量相互操作时应加类型转换 常量 const、volitile和mutable volitile 类型：易失性，优化器不对该变量的读取进行优化，用到该变量时重 新从它所在的内存读取数据。 修饰的变量可由操作系统、硬件、并发执行的线程在程序中进行修改。 mutable类型： 可变性，是const 的反义词，为突破 const的限制而设置的；被mutable 修饰的变量永远处于可变得状态，即使在 const函数中； mutable只能用来修饰数据成员；不能与 const、volatile 或 static 同时出现 定义一个常量，必须在定义时，赋初值； const 修饰符与类型修饰符可以对调 ; 常量不能在赋值号左边出现； 常量可以在赋值号右边出现； 常量的地址，只能赋值给一个常量指针; 强制访问 常量的访问：常量的地址，可以进行强制地址类型转换； 转换后，可以在赋值号左右都出现；绕过const的方法：对其地址进行强制类型转换，再解析。 外部对私有成员访问：对对象取地址然后进行指针的强制类型转换 类与常量 常成员函数 returnType func(...) const; 不可修改非静态数据成员 不得调用其他非 const 的成员函数 常对象 类名 const 对象名(实参表); 或 const 类名 对象名(实参表); 整个对象的数据成员都不允许修改。 在定义常对象时一定要初始化。 引用 定义引用变量时就一定要正确初始化，初始化后指向不可变 引用变量中存放的是被引用变量的地址； 其本质是指针； 在有串接（多级）引用时，都是指向最终被引用的变量； 与二级（多级）指针有很大的差别； 使用引用变量，操作对象都是被引用的变量 引用必须与合法的存储单元关联，不存在无法取址的量的引用（比如函数返回的临时值） 函数参数及返回值 如果某个参数给了缺省值，其右边的参数都需要给参数值。 左右值表达式 右值引用 格式：type &amp;&amp;x 右值引用也必须立即进行初始化操作，且只能使用右值进行初始化 右值引用主要用于移动语义（因此可以修改右值）和完美转发 传递右值的引用的两种方式：c++11的右值引用type &amp;&amp;x、常量左值引用const type &amp;x 函数返回右值引用时，返回值不可修改 其他 函数调用时按参数列表从右至左顺序压入栈区 类基础 关键字：深拷贝、浅拷贝 缺省构造 若程序员没有主动给类定义构造函数，编译器自动给一个缺省的构造函数。一旦程序员定义了一个构造函数，系统将不会再给出缺省构造函数。除了系统缺省的构造函数外，只要构造函数无参或者参数有缺省值， 编译器会认为它就是缺省构造函数。缺省的构造函数同时只能有1个。 析构函数一般用来释放体外空间，不用来释放本结点空间。 拷贝构造 当实例中有指针指向堆区内存时，浅拷贝得到的指针指向同一堆区空间，析构的时候就会相互影响 默认浅拷贝构造函数：Student(stu) 非法的复制构造函数：Student(Student a) 自定义深拷贝构造函数：Student(const Student &amp;a) 移动构造 函数签名：A::A(A&amp;&amp; q) 右值引用，遇到右值则优先于深拷贝构造。 功能：完成体外空间的交接以及原体外空间指针的置空（防止析构出错）。 堆分配及其初始化 new &lt;类型表达式&gt; 类型表达式是什么类型，返回的就是什么类型的指针 delete &lt;指针&gt;; 指针指向非数组的单个实体 如sq指向对象，则自动调用析构函数，再释放对象所占的内存。 delete [ ] &lt;数组指针&gt;; 指针指向任意维的数组时使用 对所有对象(元素) 自动调用析构函数。 若数组元素为简单类型，则可用delete &lt;数组指针&gt;代替 delete 并不会销毁指针本身，安全起见要手动赋值NULL 注意 new[]/delete[], new/delete, malloc/free 要搭配使用 栈分配及其初始化 形式: 对于单个实例：type obj(...) 对于对象数组：type arr[5] = {{arr[0]的构造参数}, ...} 或者去掉等号(这种方式简单类型的变量初始化也可使用：int a{1}， type arr[5] {{arr[0]的构造参数}, ...} 数据成员的初始化 在定义数据成员时赋初值，等价于在构造函数体前赋初值； 须在构造函数体前初始化： 只读成员、引用成员、对象成员 在定义对象时，自动调用构造函数初始化； 按定义的先后次序初始化，与出现在初始化位置列表的次序无关； 普通数据成员没有出现在初始化位置时，若所属对象为全局、静态 或new的对象，将具有缺省值0； 基类和非静态对象成员没有出现在初始化位置时，此时必然调用无参构造函数初始化； 如果类仅包含公有成员且没有定义构造函数，则可以采用同C兼容的初始化方式，即可使用花括号初始化数据成员； 联合类型的对象只须初始化一个成员(共享内存)； 构造函数体前初始化：只读成员、引用成员、对象成员 位置：函数签名之后，{ } 之前，:分隔 各数据成员以,分隔 用构造函数的形式给各变量赋初值，如 y(t) 可以用列表的形式{} 赋初值，如 y{t} 不能采用 = 来初始化 : y=t // error 成员指针 offsetof(类名, 成员名) 返回成员偏移的字节数（返回int类型） 成员指针的获取（在类中取址）return &amp;&lt;类名&gt;::&lt;成员名&gt; 成员指针的申明：只需要将申明一般指针用的 type * 改为 type &lt;类名&gt;::* 即可 成员指针的解析：&lt;实例&gt;.*&lt;成员指针&gt;，&lt;对象指针&gt;-&gt;*&lt;成员指针&gt; 普通成员指针是偏移量，不可移动，不可强制类型转换 成员指针为空（即= 0时）时，会自动指向0xffffffff的内存单元 构造函数不可取成员指针（否则可能造成手动调用构造函数） 静态成员指针与普通指针除了访问权限外没有差别 静态成员 静态数据成员用 static 声明 静态函数成员的访问权限及继承规则同普通函数成员没有区别 不可在体前初始化 静态数据成员独立分配内存，**不属于任何对象内存 ** 用于描述类的总体信息，如对象总数、连接所有对象的链表表头等。 静态函数成员没有this指针 访问方式： 类名::静态成员(…)； 对象.静态成员(…) ； 对象.类名::静态成员(…)。 构造函数、析构函数以及虚函数、常函数等必须有 this 参数，不能声明为static sizeof(&lt;obj&gt;)不计算&lt;obj&gt;的静态数据成员的大小 对象的存储机制 继承与权限机制 友元 友元函数 class A {... friend func(xxx); ... } 不受访问权限的限制 可以在任何访问权限下用friend 可以访问当前类的任何成员 一个函数可成为多个类的友员 友元类 class A {... friend class B; ...} 类B 的所有函数成员都是类A的友元 友元关系不传递、不对称 单继承 单继承范式12345class &lt;派生类名&gt;: [&lt;派生控制符/继承方式&gt;] &lt;基类名&gt; { &lt;派生类新定义成员&gt; &lt;派生类重定义基类同名的数据和函数成员&gt; &lt;派生类声明恢复基类成员访问权限&gt; } 派生控制权限只降不升 恢复控制权限可升可降，私有不可访 恢复权限实例1234567891011121314151617class A { protected: int x; private: int y; public: void setx(int m) { ... }};//派生类声明恢复基类成员访问权限Class B : private A { public: A::setx; // getx后面没有括号 protected: A::x; // 数据成员 private: A::y; // 不可访问A类的私有成员} C++允许父类指针指向子类对象、父类引用子类对象， 无须通过强制类型转换， 编译时按父类说明的权限访问成员 虚函数 C++ 的多态特性与虚函数密不可分，所以首先要了解多态性是什么： 具有相似功能的不同函数使用同一名称 用相同的调用方式，调用不同功能的同名函数 静态多态 函数名相同，参数不同 动态多态 函数名相同、参数相同 分属不同的类：基类与多个派生类 多态的实现： 联编：绑定、装配，将一个标识符名和一个地址联系在一起。 静态/早期联编：实现编译时多态——函数重载、运算符重载 动态/后期联编：实现运行时多态——虚函数 纯虚函数：virtual returnType funName(...) = 0 （类比于java的抽象函数），包含纯虚函数的类为抽象类，不论纯虚函数在体外是否有定义。 通过指针调用虚方法时才会查虚函数表（晚期绑定）。数据成员才会随着对象的构造滑入内存，方法不会。 析构函数需要成为虚函数以保证析构的正确性 有虚函数的类对象内存初始单元指向一个虚函数表，虚函数表内包含派生类的虚函数和派生类没有覆盖到的父类的虚函数 虚函数表的绑定 申明12345678910class A {public: A(); virtual ~A();}; //对应虚函数表VFTAclass B: A {public: B(); virtual ~B();}; //对应虚函数表VFTB 当构造一个B类对象obj，然后析构obj，在这段时间内发生的活动： 对象初始地址指向VFTA 调用A的构造函数（此时A类对象调用的虚函数与VFTA绑定，执行的虚函数将是A类的函数） 对象初始地址指向VFTB 调用B的构造函数（此时B类对象调用的虚函数与VFTA绑定，执行的虚函数将是B类的函数） 调用析构函数（此前对象的初始单元指向VFTB） 对象初始地址指向VFTA 调用析构函数 多继承 格式123456Class B: [virtual] [派生控制] 基类1, [派生控制][virtual] 基类2{ ... };派生控制：private, protected , public缺省派生控制：private在基类名称前若有：virtual , 虚基类 虚基类 虚基类共享同一片存储空间，解决了同一个物理对象初始化两次的问题（当一个物理对象只需要一个时使用） 虚基类与基类同名时，二者拥有独立的存储空间。 相同的基类不能被同时直接继承，但可以同时间接继承 构造与析构顺序 画出继承关系树（按定义顺序从左至右排列基类，箭头由子类指向父类），虚基类用方框框起来； 实例 申明1234567891011#include &lt;iostream.h&gt;struct A{ A(){ cout&lt;&lt;'A';} };struct B { const A a; B( ) { cout&lt;&lt;'B';} }; //对象成员a将作为新 根struct C{ C(){ cout&lt;&lt;'C';} };struct D{ D(){ cout&lt;&lt;'D';} };struct E：A{ E(){ cout&lt;&lt;'E';} };struct F：B, virtual C{ F(){ cout&lt;&lt;'F';} }; struct G：B{ G(){ cout&lt;&lt;'G';} };struct H：virtual C, virtual D{ H(){ cout&lt;&lt;'H';} }; struct I：E, F, virtual G, H{ E e; F f; I(){ cout&lt;&lt;'I';} };void main(void) { I i; } 运算符重载 可重载类型 强转重载 单参数的构造函数具备类型转换作用，必要时能自动将参数类型的值转换为要构造的类型。 用operator定义强制类型转换函数： operator 类型(…) 强制类型转换函数不需要定义返回类。 当用explicit修饰强转重载或单参数构造函数时，相关的隐式类型转换将不会自动进行，必须显式调用 递增（减）重载 前置++/--重载为单目运算符 后置++/--重载为双目运算符（多出来的那一目必须为int类型参数） 注意普通成员函数内隐含了一个this参数（占一目） 括号重载 构造函数的括号不受括号重载的影响 模板 函数模板 1234template &lt;模板形参表&gt; 返回类型 函数名 (参数表) { &lt;函数体&gt;} &lt;模板形参表&gt;可以包含一个或多个用逗号分开的参数，每一项均有内置关键字class或typename引导一个标识符 T 此标识符为模板参数，表示一种数据类型 type是基本数据类型，class是类类型 参数表中至少有一个参数说明 参数在函数体中至少应用一次 类模板同上 类模板 1234567template &lt;模板形参表&gt; class 类名 { &lt;类体说明&gt;};//类模板的成员函数体外定义时类名&lt;T&gt;::成员函数(params) {...} 模板与继承 类模板可以从非模板类派生（注意模板类和类模板的区别） 类模板可以从类模板派生 实例12template &lt;class T&gt;class A: public B&lt;T&gt; {...}; //B是模板形参表有一个class类型参数的类模板 非模板类可以从类模板派生 注意事项 类模板的成员函数是在调用时才被创建，导致分文件编写时调用不到 解决方案：将实现与申明写在同一个文件，推荐使用.hpp 异常处理 异常 抛出的异常分类：内置数据类型异常，标准异常，自定义类对象，不接任何对象（throw;只能用于于catch块中，作用是将异常传递到上一级catch块） try-throw-catch：监视-抛出-捕获，catch到一个对象时调用以对象为参数的构造函数（拷贝/移动构造） 异常接口：returnType func() throw(...) {}（noexcept与throw()几乎等价） set_terminate(), set_unexpect()：设置自定义终止函数（异常传递到顶层时调用终止函数），设置自定义处理不可预料异常的函数（函数产生有悖于异常接口说明的异常类型时调用）。 析构问题 如果通过new产生的指针类型的异常，在catch 处理后，通常应使用delete释放内存； 如果继续传播指针类型的异常，则可以不使用 delete；从最内层被调函数抛出异常到外层调用函数的catch处理过程捕获异常，由此形成的函数调用链所有局部对象都会被自动析构，因此使用异 常处理机制能在一定程度上防止内存泄漏； 调用链中通过new分配的内存不会自动释放； 特殊情况在产生异常对象的过程中也会出现内存泄漏情况：未完成构造的对象。 异常与继承 如果父类A的子类为B，B类异常能被catch(A)、 catch(const A)、 catch(volatile A)、 catch(const volatile A)等捕获。 如果父类A的子类为B，指向可写B类对象的指针异常也能被catch(A*)、 catch(const A*)、 catch(volatile A*)、 catch(const volatile A)等捕获。 因此捕获子类对象的catch应放在捕获父类对象的 catch前面。 catch(const volatile void *)能捕获任意指 针类型的异常，catch(…)能捕获任意类型的异常。 断言 &lt;asset.h&gt; asset(int expr)，expr为假时进入断言函数(会输出断言表达式、断言发生的文件名和行号) 静态断言static_asset(int expr)（编译时检查） 类型推导与转换 传统转换 显式转换 格式：(T)expr 一般类型转换得到右值: (T)expr，**左值引用转换得到左值: **(T&amp;)expr const T无法转为T，但可以通过指针类型*(T*)&amp;或引用类型(T&amp;)来转换 隐式转换 由编译器自动完成 场景：传参时、赋值时、运算时 转换规则： 非浮点类型字节少的向字节数多的转换：bool、char、short和int的运算按int类型进行。 非浮点类型有符号数向无符号数转换：所有浮点常量及浮点数的运算按double类型进行。 运算时整数向double类型的转换。 cast转换 格式：XXX_cast&lt;T&gt;(expr) //将expr转化为目标类型T static_cast 编译时检查是否可以转换 不能去除源类型的const或volatile 目标类型不能包含存储位置类修饰符，如static、extern、 auto、register等 const_cast 目标类型必须是指针、引用、或者指向对象成员的指针 类型表达式不能包含存储位置类修饰符 不能将无址常量、位段访问、无址返回值转换为有址引用 dynamic_cast 目标类型必须是类的引用、类的指针或者void*类型 源类型必须是类的对象、对象地址 用于子类向父类转换，以及有虚函数的基类向派生类转换 不能去除源类型中的const和volitale reinterpret_cast 用于有址引用与无址引用之间的相互转换、指针或引用类型的转换、足够大整数与指针类型的转换 typeid 获得对象的真实类型标识 格式 typeid(类型表达式) typeid(数值表达式) typeid的返回结果是const type_info&amp;类型 在使用typeid之前可先#include &lt;typeinfo&gt;，使用std名字空间。 decltype 提取表达式的类型，构成新的类型表达式 decltype(expr) decltype 实例123456int x = 10;decltype(x) y; // int y;int a1[10];decltype(a1) p1; // int p1[10]; p1的类型是 int[10]decltype(a1) *p11; // int (*p11)[10] Lamda 表达式 形式：[捕获列表](形参列表) mutable 异常说明-&gt;返回类型{函数体} 使用：auto fuc = [Lambda expr]; fuc(params); mutable: 可选，用于说明是否可以修改捕获变量 捕获列表说明： 捕获列表的参数用于捕获Lambda表达式的外部变量； 外部变量可以是函数参数或函数定义的局部自动变量； 出现&amp;变量名表示引用外部变量； [&amp;]表示捕获所有函数参数或函数定义的局部自动变量。 出现=变量名表示使用外部变量的值（值参传递), [=]表示捕获所有函数参数或函数定义的局部自动变量的值； 外部变量不能是全局变量或static定义的变量； 外部变量不能是类的成员； 参数表后有mutable表示在Lambda表达式可以修改“值参传递的值”，但不影响Lambda表达式外部变量的值。 Lambda表达式被编译为临时类的对象，临时类重载了函数operator()","link":"/posts/98759b98/"},{"title":"技术&#x2F;笔记&#x2F;操作系统原理课程笔记","text":"OS 课程笔记 第一章 绪论 操作系统的定义 操作系统是一个大型的程序系统，它负责计算机系统软、硬件资源的分配；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境。 操作系统的特征 并发 共享 不确定性 多道程序设计技术 定义 在计算机主存中同时存放几道相互独立的程序。这些程序在管理程序控制之下，相互穿插地运行。当某道程序因某种原因不能继续运行下去时(如等待外部设备传输数据)，管理程序便将另一道程序投入运行。 特征 多道 微观上串行 宏观上并行 应用 批处理操作系统（系统吞吐率高：脱机操作 、多道运行、 合理搭配作业；作业周转时间长，用户使用不方便） 依赖 通道技术和中断技术 多道程序工作示例 分时技术 定义 所谓分时技术，是把处理机时间划分成很短的时间片(如几百毫秒)轮转地分配给各个应用程序使用，如果某个程序在分配的时间片用完之前计算还未完成，该程序就暂时中断，等待下一轮继续计算。 应用 分时操作系统（独占性、并行性、交互性） 第二章 结构与硬件支持 处理机的态 定义 处理机的态，又称为处理机的特权级，是中央处理机的工作状态。当前处理机正在执行哪类程序，决定处理机的态。 分类 核态：操作系统的管理程序执行时机器所处的状态，又称处理机的特权级。在此状态下处理机可使用全部指令(包括一组特权指令)；使用全部系统资源(包括整个存储区域)。 管态：管态比核态的权限低，在此状态下允许使用一些用户态下不能使用的资源，但不能使用修改CPU状态的指令。无核态时，管态执行核态的全部功能。 用户态（目态）：用户程序执行时机器所处的状态称为用户态。在此状态下禁止使用特权指令，不能直接取用资源与改变机器状态，并且只允许用户程序访问自己的存储区域。 管态 用户态 操作系统的程序执行 用户程序执行 使用全部指令 禁止使用特权指令 使用全部系统资源 只允许用户程序 整个存储区域 访问自己的存储区域 特权指令集 ① 涉及外部设备的输入/输出指令 ② **修改特殊寄存器的指令：**存取用于主存保护的寄存器等 ③ **改变机器状态的指令:**开/关中断、进程切换、停机指令等 状态切换 ① 用户态到管态 管理程序调用 中断 用户进程产生错误（内部中断） 用户程序企图执行特权指令 ② 管态到用户态 ​ 从核态转回用户态用一条指令实现，这条指令也是特权指令。一般情况下是中断返回指令。 中断 概念 所谓中断是指某个事件 (例如电源掉电、定点加法溢出或I/O传输结束等) 发生时，系统中止现行程序的运行、引出处理事件程序对该事件进行处理，处理完毕后返回断点继续执行的过程。 按中断源分类 ① 中断： 由处理机外部事件引起的中断，包括输入输出中断、外中断。（x86中称为异步中断） ② 俘获： 由处理机内部事件引起的中断，包括访管中断、程序性中断、机器故障中断。（x86中称为异常） 优先级：俘获 &gt; 中断 第三章 用户接口 命令接口 操作命令 程序接口 系统功能调用 系统调用与库函数 系统调用代码属于OS，库函数由软件开发商提供，由编译工具链入用户程序 系统调用代码的执行引起CPU状态的变化：用户态 =&gt; 核心态 库函数的执行不会引起CPU状态的变化：用户态 系统调用封装成库函数 访管中断 当处理机执行到访管指令时发生中断，该中断称为访管中断，它表示正在运行的程序对操作系统的某种需求。 第四章 进程管理 并发程序 定义 若干个程序段同时在系统中运行，这些程序段的执行在时间上是重叠的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重叠是很小的一部分，也称这几个程序段是并发执行的。 并行记号 1234/*表示S1,S2,....Sn这n个语句是可以并发执行的*/cobegin S1;S2;...;Sn;coend 先后次序图 对n个用户作业的处理 1234作业1： I1 C1 P1作业2： I2 C2 P2 ...作业n： In Cn Pn 誊抄 (g: get, c: copy, p: put) 特点 失去了程序的封闭性和可再现性 程序与计算不再一一对应 程序并发执行的相对制约 进程 定义 进程，即是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。 进程与程序的区别 ① 程序是静态的概念，进程是动态的概念； ② 进程是一个独立运行的活动单位； ③ 进程是竞争系统资源的基本单位； ④ 一个程序可以对应多个进程，一个进程至少包含一个程序 进程变迁 状态：就绪、等待、运行 状态变迁 变迁原因 123456789101112131415就绪 --&gt; 运行 调度程序选择一个新的进程运行 运行 --&gt; 就绪 运行进程用完了时间片 运行进程被中断，因为一高优先级进程处于就绪状态 运行 --&gt; 等待 当一进程必须等待时 OS尚未完成服务 对一资源的访问尚不能进行 初始化I/O 且必须等待结果 等待 --&gt; 就绪 当所等待的事件发生时 因果变迁 进程描述 进程控制块 PCB 定义：描述进程与其他进程、系统资源的关系以及进程在各个不同时期所处的状态的数据结构 作用：进程与PCB是一一对应的，系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志 进程的组成 程序和数据 PCB 进程控制 控制原语 创建、撤销、阻塞（等待）、唤醒 互斥与同步机制 临界资源、临界区 一次仅允许一个进程使用的资源称为临界资源；硬件：如输入机、打印机、磁带机等；软件：如公用变量、数据、表格、队列等 进程中对公共变量 (或存储区)进行审查与修改的程序段，称为相对于该公共变量的临界区。 准则 12345有空让进：当无进程在互斥区时，任何有权使用互斥区的进程可进入。无空等待：不允许两个以上的进程同时进入互斥区。多中择一：当没有进程在临界区，而同时有多个进程要求进入临界区，只能让其中之一进入临界区，其他进程必须等待。有限等待：任何进入互斥区的要求应在有限时间内得到满足。让权等待：当进程不能进入临界区时，应立即释放CPU，避免进程忙等待。 上锁原语、开锁原语 (0为无锁，1为上锁) P、V 操作原语 进程流图 示例 两类同步问题解决方案 一般的合作问题：画进程流图，对pi设置si信号灯表示pi是否可以开始 共享缓冲区的合作问题（生产者-消费者问题）：设置有界缓冲区互斥锁、满个数、空个数三个信号灯 进程通信 P、V 原语：简单的同步信号通讯 共享内存 消息通信 管道 socket: 不同（相同）主机间进程通信 线程 第五章 资源分配与调度 数据结构 资源信息块结构（后面几章中的处理及资源信息块、主存资源信息块、设备资源信息块等都类似这种结构） 分配策略 先请求先服务 优先调度 死锁 产生死锁的必要条件 ① 互斥条件 涉及的资源是非共享的，即为临界资源。 ② 不剥夺条件 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走。 ③ 部分分配 进程每次申请它所需要的一部分资源。在等待一新资源的同时，进程继续占用已分配到的资源。 ④ 环路条件 存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中下一个进程所请求。 死锁定理 如果资源分配图中没有环路，则系统中没有死锁，如果图中存在环路则系统中可能存在死锁。 如果每个资源类中只包含一个资源实例，则环路是死锁存在的充分必要条件。 预防死锁 静态预防：在作业调度时为选中的作业分配它所需要的所有资源，当资源一旦分配给该作业后，在其整个运行期间这些资源为它独占。 动态预防 有序资源分配法（破坏环路条件）：给不同类的资源编号，进程必须按照编号升序请求资源，且申请同一类资源时必须一次申请完 银行家算法：申请者事先说明对各类资源的最大需求量。在进程活动期间动态申请某类资源时，由系统审查现有该类资源的数目是否能满足当前进程的最大需求量，如能满足就予以分配，否则拒绝。 安全序列的定义：指系统能按某种进程推进顺序（Pi1，Pi2，。。。Pin）为每个进程分配其所需的资源，直至每个并发进程都能达到获得最大资源而顺序完成，此时称(Pi1，Pi2，。。。Pin）为安全序列。 能找到安全序列的状态为安全状态。 第六章 处理机调度 作业调度算法 先来先服务 短作业优先 响应比高者优先 响应比=响应时间/计算时间=1+等待时间/计算时间\\text{响应比} = \\text{响应时间} / \\text{计算时间} = 1 + \\text{等待时间} / \\text{计算时间}响应比=响应时间/计算时间=1+等待时间/计算时间 优先数 进程调度算法 调度方式：剥夺、非剥夺 优先数调度算法 静态优先数 动态优先数 循环轮转调度算法 简单循环轮转 可变时间片循环轮转 多重时间片循环轮转 调度用的进程状态变迁图 调度效果：优先照顾IO量大的进程；适当照顾计算量大的进程。 第七章 主存管理 基本概念 虚实分离 逻辑地址、程序地址空间 物理地址、主存空间 地址映射 静态地址映射（编译/装入时映射） 动态地址映射（运行时） 存储保护 上下界法 基地址-限长法 分区存储管理 分区分配数据结构 放置策略 （选择空闲区的策略） 首次适应算法 （空闲区队列按地址由低到高排列） 最佳适应算法 （空闲区队列按大小由小到大排列） 最坏适应算法 （空闲区队列按大小由大到小排列） 页式存储管理 页式地址变换 请调策略 扩充页表功能 —— 中断位 辅存地址 缺页处理 淘汰策略 扩充页表功能 —— 引用位 改变位 抖动 置换算法 先进先出算法 最久未使用 LRU 算法 （计数法、多位寄存器法、栈方法） LRU 近似算法 （时钟） 第八章 设备管理 设备独立性 所谓设备独立性是指，用户在程序中使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名。 缓冲技术 双缓冲、环形缓冲、缓冲池 磁盘调度算法 先来先服务 FCFS 最短寻道优先 SSTF 扫描算法 SCAN 循环扫描算法 CSCAN 设备分配 独享分配 共享分配 虚拟分配 Spooling 系统 利用通道和中断技术，在主机控制之下，由通道完成输入输出工作。系统提供一个软件系统 (包括预输入程序、缓输出程序、井管理程序、预输入表、缓输出表)。它提供输入收存和输出发送的功能，使外部设备可以并行操作。这一软件系统称为SPOOLING系统 第九章 文件系统 文件的逻辑结构 流式文件 流式文件是相关的有序字符的集合，是无结构的。流式文件是按信息的个数或以特殊字符为界进行存取的。 记录式文件 记录式文件是一种有结构的文件。这种文件在逻辑上总是被看成一组连续顺序的记录的集合。 按照每个记录长度是否固定分为：定长记录、变长记录 文件的物理结构 连续文件 串联文件 FAT 文件 （采用文件分配表，将串联文件中的勾链字集中在一起存放，通常从磁盘第二个扇区开始存放） FATX 中的 X 表示一个块号（簇号）占多少位 以FAT16为例，勾链字0000H表示空闲块，FFFFH表示结尾 索引文件 多级索引 直接索引 一级、二级、三级间接索引 Unix 系统的 i 结点 默认情况下一个磁盘块的大小为 512 Byte，一个块号占据 2 Byte Unix 7 i_addr[8] 小型文件 i_addr[0...7] 直接索引，8×512B8 \\times 512B8×512B 大型文件 i_addr[0...6] 一级间接索引，i_addr[7] 空置，7×256×256B7 \\times 256 \\times 256B7×256×256B 巨型文件 i_addr[0...6] 一级间接索引，i_addr[7] 二级间接索引，(7×256+2562)×512B(7\\times256 + 256^2 )\\times512B(7×256+2562)×512B Unix System V i_addr[13] i_addr[0...9] 直接索引 i_addr[10] 一级间接索引 i_addr[11] 二级间接索引 i_addr[12] 三级间接索引 空闲块管理之成组链接法 结构：s_nfree 为空闲块数，s_free为空闲块号数组（大小为100），s_free[0] 比较特殊因为它不仅仅是某个空闲块号而且它所指向的空闲块又是一个空闲块索引表 分配-释放算法 文件目录 一级文件目录 树型文件目录 硬链接和软链接","link":"/posts/eaace690/"},{"title":"算法&#x2F;算法分析与设计","text":"算法 第一、二章 基本概念 纲要 循环不变式 伪代码范式 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。 Q&amp;A 算法的基本概念和性质 算法是一组有穷的规则，它规定了解决某一特定类型问题的一系列运算 什么是循环不变式？用循环不变关系证明循环的正确性 在第一次进入循环之前成立、以后每次循环之后还成立的关系 分三步走： 1）初始化：证明初始状态时循环不变式成立，即证明循环不变式在循环开始之前为真； 2）保持：证明每次循环之后、下一次循环开始之前循环不变式仍为真； 3）终止：证明循环可以在有限次循环之后终止，终止时循环不变式依然为真 第三章 纲要 上界、下界、渐进紧确界：Ω、O、Θ 非渐进紧确界：w、o 限界函数性质：传递性、自反性、对称性、转置对称性 相关定理（用于估算限界函数）：多项式定理、阶大小定理 指数时间算法、多项式时间算法 n 较大时，大于nlogn的算法比较困难 Q&amp;A 第四章 分治策略 纲要 最大子数组问题 化简递归式：代换法、递归树法、主方法 代换法：预处理、猜测解、数学归纳法证明 递归树法：预处理、画递归树、求极限和、数学归纳法证明 运用主定理 展开法直接化简 Q&amp;A 分治法的基本思想 当问题规模比较大而无法直接求解时，将原始问题分解为几 个规模较小、但类似于原始问题的子问题，然后递归地求解这些 子问题，最后合并子问题的解以得到原始问题的解。 分解、解决、合并 第八章 线性时间排序 纲要 最坏情况下，任何排序算法都要进行Ω(nlgn)次比较 桶排序、归并排序为渐进最优排序算法，时间复杂度为f(n)=O(nlgn) 第十五章 纲要 经典问题 钢条切割问题 O(n2)O(n^2)O(n2) 矩阵链乘 O(n3)O(n^3)O(n3) 最长公共子序列问题LCS O(nm)O(nm)O(nm) 最优二叉搜索树 O(n3)O(n^3)O(n3) 估算时间复杂度 子问题图法：Σ所有结点结点出度Σ_{\\text{所有结点}}\\text{结点出度}Σ所有结点​结点出度 Σ所有子问题解决一个子问题要用的操作数Σ_{\\text{所有子问题}}\\text{解决一个子问题要用的操作数}Σ所有子问题​解决一个子问题要用的操作数 最优子结构和子问题无关性 最长简单路径不满足子问题无关性 剪切-粘贴法 Q&amp;A 最优化问题是一类什么问题？ 这一类问题的可行解可能有很多个。每个解都有一个值，我们希望寻找具有最优值的解（最小值或最大值） 简述对动态规划所能带来计算性能改进的理解 备份子问题的解，空间换时间 什么是状态转移方程 即问题状态的递推关系式 第十六章 贪心算法 纲要 基本思想 分步骤实施，它在每一步仅作出当时看起来最佳的选择，即局部最优的选择，并寄希望这样的选择最终能导致全局最优解，（贪心选择性质） 经典问题 最小生成树问题的Prim算法、Kruskal算法，单源最短 路径Dijkstra算法等，以及一些近似算法 活动选择问题 O(n)O(n)O(n)：每次选择最早结束的活动加入集合 哈夫曼编码：每次移除队列中频率最低的两个结点合并成一个结点加入队列 尾递归可以轻松地转化为循环式 可以解决分数背包问题 O(nlogn)O(nlogn)O(nlogn)，不能解决0-1背包问题 Q&amp;A 贪心算法的基本思想和一般步骤 基本思想：通过选择局部最优来导致全局最优 确定问题的最优子结构； 将最优化问题转化为这样的形式：每次对其作出选择后，只剩下一个子问题需要求解； 证明作出贪心选择后，剩余的子问题满足：其最优子解与前面的贪心选择组合即可得到原问题的最优解(具有最优子结构)。 什么是贪心选择性和贪心选择? 贪心选择性质：可以通过做出局部最优（贪心）选择来构造 全局最优解的性质。 在贪心算法的每一步所做的当前最优选择（局部最优选择）就叫做贪心选择 比较动态规划和贪心方法的异同。 贪心算法可以直接进行贪心选择，而动态规划必须要比较各种选择决出最优选择 贪心算法和动态规划都需要问题满足最优子结构和子问题无关性 第二十章 基本的图算法 纲要 邻接表、邻接矩阵 BFS、DFS 活结点、E-结点、死结点 回溯法 使用限界函数的深度优先状态结点生成方法称为回溯法 分支-限界法 使用限界函数的E结点一直保持到死为止（中间不会经历活结点状态）的状态结点生成方法称为分支-限界方法（宽度优先） 两种策略——FIFO检索：活结点表采用队列、LIFO检索：活结点表采用栈 LC检索(A*算法) 选择C^(X)\\hat{C}(X)C^(X)值最小的活结点作为下一个E-结点的状态空间树检索方法 成本估计函数 C^(X)=g^(X)+f(h(x))\\hat{C}(X) = \\hat{g}(X) + f(h(x))C^(X)=g^​(X)+f(h(x)) C(X)C(X)C(X) 成本函数，只有当整个状态空间树生成出来时才知道 g^(X)\\hat{g}(X)g^​(X) 是由X到达一个答案结点所需成本的估计函数 h(X)h(X)h(X) 是根节点到X的成本——已发生成本 f(X)f(X)f(X) 是某一个不减函数 BFS和D_Search是特殊的LC检索，对于BFS有 g^(X)=0\\hat{g}(X)=0g^​(X)=0，f(h(x))=f(h(x))=f(h(x))= 结点深度；对于DSearch有f(h(x))=0f(h(x)) = 0f(h(x))=0，XXX越深g^(X)\\hat{g}(X)g^​(X)越小 利用分支限界法求解最优化问题 利用成本估计函数（成本下界）C^(X)\\hat{C}(X)C^(X)智能地选择下一个E-结点 成本上界UUU由答案结点的成本C(X)C(X)C(X)所更新，扩展结点时舍去 C^(X)&gt;U\\hat{C}(X) &gt; UC^(X)&gt;U 的结点 典型例题：带限期的作业排序问题 Q&amp;A BFS、DFS、D_Search的区别 简述 LC-检索的基本思想 选择成本估计最小的活结点作为下一个E-结点的状态空间树检索方法，以此来加快找到一个可行解 什么结点成本函数和结点成本估计函数？结点成本估计函数中h函数和𝑔̂函数会分别对算法带来什么影响？ 结点成本函数是指经过该结点到达可行解的最小实际成本 结点成本估计函数是对结点成本函数的估计 h(X)h(X)h(X)函数使得算法优先考虑距离答案结点更近的结点作为下一个活动结点 g^(X)\\hat{g}(X)g^​(X) 函数使得算法优先考虑离根结点更近的结点（已发生成本更低） 了解𝑔̂函数的性质，了解C(X)上界的作用 单纯使用g^(X)\\hat{g}(X)g^​(X)选择E结点会导致算法偏向纵深检查 C(X)上界能够杀死那些明显成本更大活结点，加速算法，降低检索的盲目性 第二十三章 最小生成树 最小生成树的生成 第二十四章 单源最短路 纲要 基本概念 前驱子图 Gπ(Vπ,Eπ)G_\\pi (V_\\pi, E_\\pi)Gπ​(Vπ​,Eπ​)，最短路径树（算法终止后的最终 GπG_\\piGπ​） 即VπV_\\piVπ​是图G中的前驱结点不为NIL的结点的集合，再加上源点s 即EπE_\\piEπ​是由VπV_\\piVπ​中的结点的π\\piπ值所“诱导”的边的集合 前驱节点 v.πv.\\piv.π，最短路径长度上界 v.dv.dv.d 最短路径的最优子结构：两个结点之间的最短路 径的任何子路径都是最短的。 如果存在负权重的边，则有可能存在权重为负值的环路， 而造成图中最短路径无定义。 最短路不应包含环路：简单路径 算法证明 路径松弛性质：Relax(u,v,w)Relax(u, v, w)Relax(u,v,w) 后有 v.d≤u.d+ω(u,v)v.d \\leq u.d + \\omega (u,v)v.d≤u.d+ω(u,v) 三角不等式性质 δ(s,v)≤δ(s,u)+ω(u,v)\\delta (s, v) \\leq \\delta (s, u) + \\omega (u, v)δ(s,v)≤δ(s,u)+ω(u,v) 上界性质 δ(s,v)≤v.d\\delta (s, v) \\leq v.dδ(s,v)≤v.d 收敛性质：松弛操作 relax(u,v)relax(u,v)relax(u,v) 前有 u.d=δ(s,u)u.d = \\delta (s, u)u.d=δ(s,u) 则松弛后必有 v.d=δ(s,v)v.d = \\delta (s, v)v.d=δ(s,v) Bellman-Ford 算法 O(VE)O(VE)O(VE) 可以有负权重的边，但不能有负权重的环 Dijkstra 算法 不能有负权重的边和环 时间复杂度： 差分约束系统 约束图 边的权重：如果 xj−xi≤bkx_j - x_i \\leq b_kxj​−xi​≤bk​ 是一个差分约束条件，则边 (vi,vj)(v_i ,v_j)(vi​,vj​) 的权重记为$ ω(v_i ,v_j ) = b_k$ ，而从v0v_0v0​出发到其他结点的边的 权重 ω(v0,vj)=0ω(v_0 ,v_j)=0ω(v0​,vj​)=0 问题归约 如果图G不包含权重为负值的回路，则 (δ(v0,v1),δ(v0,v2),...,δ(v0,vn))(\\delta (v_0, v_1), \\delta (v_0, v_2), ..., \\delta (v_0, v_n))(δ(v0​,v1​),δ(v0​,v2​),...,δ(v0​,vn​)) 为差分约束系统的一个可行解（用三角不等式证明） 如果图G包含权重为负值的回路，则该系统没有可行解 Q&amp;A 什么是松弛操作？ 举例说明在带有负权重边的图上 Dijkstra 算法工作异常。 Bellman-Ford 算法是如何检查图中可能存在的负权重回路的？ 对每条边松弛迭代V-1次之后，检查所有边 (u,v)(u,v)(u,v) 看看是否有 v.d&gt;u.d+w(u,v)v.d &gt; u.d + w(u,v)v.d&gt;u.d+w(u,v)，如果有说明存在负权重回路，否则不存在。 第二十五章 多元最短路 纲要 成本邻接矩阵W，最短路径矩阵D，前驱结点矩阵Π Floyd-Warshall 算法 O(v3)O(v^3)O(v3) 算法允许图中存在负权重的边，但不能存在权重为负值的环路 特殊应用：计算传递闭包T（min=&gt;∨min=&gt;\\lormin=&gt;∨ 、+=&gt;∧+ =&gt; \\land+=&gt;∧） Johnson 算法 O(n3)O(n^3)O(n3) 用于稀疏图 重赋权重+单源最短路法： 如果图G包含权重为负值的边，但没有权重为负值的环路， 则通过重赋权重，构造出一组新的非负权重值，然后通过对每个结点运行一次Dijkstra算法来找到所有结点对之间的最短路径 新权值 w^\\hat{w}w^ 要满足路径等价性和非负性 w^(u,v)=w(u,v)+h(u)−h(v)\\hat{w} (u,v) = w(u,v) + h(u) - h(v)w^(u,v)=w(u,v)+h(u)−h(v)，其中 h(u)=δ(s,u),h(v)=δ(s,v)h(u) = \\delta(s, u), h(v) = \\delta(s, v)h(u)=δ(s,u),h(v)=δ(s,v)，sss 为辅助点且满足 w(s,v)=0,v∈Vw(s,v) = 0, v \\in Vw(s,v)=0,v∈V 算法思想： 先用Bellman-Ford算法计算s到各个结点的最短路径，并判断是否存在负权重的环路 利用Bellman-Ford算法计算得到的δ(s,v)定义h(v)的值，并重新赋边的权重 还原路径权重，得到原图的路径权重矩阵D 第二十六章 最大流 纲要 流网络 是一个带有源/汇点，每条边带有容量限制的有向图 G(V,E)G(V,E)G(V,E) 流网络是连通图 不允许自循环 流的性质 容量限制：0≤f(u,v)≤c(u,v)0 \\leq f(u,v) \\leq c(u,v)0≤f(u,v)≤c(u,v)，fff为实际流量，ccc为容量，u,v∈Vu,v \\in Vu,v∈V 流量守恒：除了源/汇点之外的点流入和流出的流量大小相同 标准流网络：无反向平行边，单一源/汇点 一般流网络标准化方法：新增结点法 对于反平行边，引入结点将其截断 对于多个源/汇点，引入一个超级源/汇点，令其到原来的源/汇点的容量限制均为∞ Ford-Fulkerson 算法步骤 对流网络 GGG，在残存网络 GfG_fGf​ 中寻找一条增广路径 ppp。 如果存在增广路径，则对路径上边的流量进行修改，以增加流网络的流量。 重复这一过程，直到不再存在增广路径为止。 流网络的切割 Edmonds-Karp 算法 找增广路径时采用广度优先搜索策略 最大二分匹配 新增源/汇点 所有边容量为1 Q&amp;A 什么是流网络、最大流？ 最大流最小切割定理 以下三个条件等价: f是G的一个最大流 残存网络不包括任何增广路径 ∣f∣=c(S,T)|f|= c(S,T)∣f∣=c(S,T) ，其中(S,T)是流网络G的某个切割 Edmonds-Karp 算法的思路和相关证明","link":"/posts/77d3606/"},{"title":"技术&#x2F;笔记&#x2F;《第一行代码：Android》读书笔记（三）","text":"Android Kotlin 读书笔记 简介 \"《第一行代码：Android 3rd》第九章和第十章的读书笔记，主要内容包括四大组件中的Service以及一些手机多媒体的使用。\" 为方便笔记，约定使用伪Kotlin语法： &lt;!ClassName&gt; 用来表示ClassName类的一个实例 &lt;Abstract&gt;或&lt;A&gt; 写在方法(类)前用来表示该方法（类）是一个必须要给出实现的抽象方法/类 &lt;Static&gt;或&lt;S&gt;写在方法(类)前用来表示该方法（类）是一个静态的方法/类 &lt;+&gt; 表示public方法 O 是override的缩略 XXX 表示待定的语法字符串 ... 表示前后代码段省略 UML 图的规定： 斜体函数*为抽象函数 下划线函数$为静态函数 以下前缀代表访问权限 + Public - Private # Protected ~ Package/Internal 丰富多彩的多媒体 使用通知 概览 classDiagram class NotificationManager { +notify() +createNotificationChannel() } class NotificationChannel class NotificationCompat { +Builder() } NotificationCompat --> Notification: 创建 NotificationManager --> NotificationChannel: 创建、管理 NotificationManager --> Notification: 发送 Notification --* NotificationChannel: 对应 NotificationManager 类 创建：val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotifictionManager 备注：getSystemService() 是 Context 的一个用来获取系统服务方法。 NotificationChannel 类 每条通知都要属于一个对应的渠道。每个应用程序都可以自由地创建当前应用拥有哪些通知渠道，但是这些通知渠道的控制权是掌握在用户手上的。用户可以自由地选择这些通知渠道的重要程度，是否响铃、是否振动或者是否要关闭这个渠道的通知。 创建通知渠道12345678if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { // 通知渠道是v8.0新增的API，需要做下版本判别才能使用NotificationChannel val channel = NotificationChannel(channelId: String, channelName: String, importance) //构造通知渠道实例 渠道标识串 向用户显示的渠道名称 重要等级 &lt;!NotificationManager&gt;.createNotificationChannel(channel) //创建通知渠道 } 通知渠道重要等级：IMPORTANCE_HIGH、IMPORTANCE_DEFAULT、IMPORTANCE_LOW、IMPORTANCE_MIN，用不同level构造的channel会有不同的表现，如HIGH级别的渠道会弹出通知。 Notification 类 可以在 Activity（较少）、Broadcast、Service 中创建 通知の构建与发送1234567891011121314//用AndroidX库的NotificationCompat类来构建通知要比原API兼容性更好val notification = NotificationCompat.Builder(context, channelId: String)//通知要对应唯一一个channel .setContentTitle(title: String) .setContentText(text: String) .setContentIntent(pi: PendingIntent)//点击事件 .setSmallIcon(R.drawable.small_icon) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.large_icon)) .setAutoCancel(true)//点击通知后通知消失 //可以连缀多个set方法来赋予通知各种属性 .build()//构建 //通过管理器发送&lt;!NotificationManager&gt;.notify(id: Int, notification: Notification)// 通知的标识符 通知 通知属性(进阶)：.setStyle() 方法——让通知呈现富文本 flowchart TD Style --> BigPictureStyle; Style --> BigTextStyle setStyle 举例12345//大图片.setStyle(NotificationCompat.BigPictureStyle().bigPicture( BitmapFactory.decodeResource(resources, R.drawable.big_image)))//长文字.setStyle( NotificationCompat.BigTextStyle().bigText(string: String) ) 点击事件 为通知设置点击事件：.setContentIntent(pi: PendingIntent) 构建PendingIntent123&lt;S&gt; PendingIntent.getXXX(ctx: Context, 0, intent: Intent, flag: Int): PendingIntent//para4用于确定PendingIntent的行为，一般可取0详，情查文档//XXX可以是Activity、Broadcast、Service 调用摄像头与相册 From Camera flowchart TB A[fa:fa-camera-retro intent机制呼出相机拍照] 获取对应的Uri对象 --> 给intent传入Uri指定相片将写入的文件 A --> 将拍摄的照片显示出来 创建对应路径的File对象 --> 获取对应的Uri对象 给intent传入Uri指定相片将写入的文件 --> A 相机实例1234567891011121314151617181920212223242526272829303132333435363738394041class MainActivity : AppCompatActivity() { lateinit var imageUri: Uri lateinit var outputImage: File override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) //step1 outputImage = File(externalCacheDir, \"output_image.jpg\") if (outputImage.exists()) { outputImage.delete() } outputImage.createNewFile() //step2 imageUri = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { FileProvider.getUriForFile(this, \"com.example.cameraalbumtest.fileprovider\", outputImage) } else { Uri.fromFile(outputImage) }//从Android 7.0系统开始，直接使用本地真实路径的Uri被认为是不安全的，会抛出一个FileUriExposedException异常。 //而FileProvider则是一种特殊的ContentProvider，它可以选择性地将封装过的Uri共享给外部，从而提高了应用的安全性。 //step3~4 val intent = Intent(\"android.media.action.IMAGE_CAPTURE\") intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri) startActivityForResult(intent, takePhoto) } //step5 override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { takePhoto -&gt; { if (resultCode == Activity.RESULT_OK) {val bitmap = BitmapFactory.decodeStream(contentResolver.openInputStream(imageUri)) imageView.setImageBitmap( bitmap) } } } } ...} 代码中用到&quot;com.example.cameraalbumtest.fileprovider&quot;，需要在Manifest中注册。 fileprovider注册示例123456789&lt;provider android:name=\"androidx.core.content.FileProvider\" //固定不变 android:authorities=\"com.example.cameraalbumtest.fileprovider\" //与FileProvider.getUriForFile()第二个参数一致 android:exported=\"false\" //是否允许外部使用 android:grantUriPermissions=\"true\"&gt; &lt;meta-data //指定Uri共享路径 android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/file_paths\" /&gt;&lt;/provider&gt; res/xml/file_paths.xml文件示例12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;paths xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;external-path name=\"my_images\" path=\"/\" /&gt; // 随意 指定共享目录&lt;/paths&gt; From Album flowchart LR 发送请求Intent-->接受并处理结果Result 相簿示例12345678910111213141516171819202122232425class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { //*step1 val intent = Intent(Intent.ACTION_OPEN_DOCUMENT) intent.addCategory(Intent.CATEGORY_OPENABLE) intent.type = \"image/*\" startActivityForResult(intent, fromAlbum) } //step2 override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { fromAlbum -&gt; { if (resultCode == Activity.RESULT_OK &amp;&amp; data != null) { data.data?.let { uri -&gt; val bitmap = getBitmapFromUri(uri) imageView.setImageBitmap(bitmap) } } } } } 播放多媒体文件 音频概览 classDiagram class Activity { getAssets(); } class AssetManager { +openFd(); } class MediaPlayer { +setDataSource(); +prepare(); } Activity-->AssetManager: 创建 AssetManager-->MediaPlayer: 提供播放资源 MediaPlayer 类 MediaPlayer 可以用于播放网络、本地、app安装包中的音频 方法名 功能描述 setDataSource() 设置要播放的音频文件的位置 prepare() 在开始播放之前调用，以完成准备工作 start() 开始或继续播放音频 pause() 暂停播放音频 reset() 将MediaPlayer对象重置到刚刚创建的状态 seekTo() 从指定的位置开始播放音频 stop() 停止播放音频。调用后的MediaPlayer对象无法再播放音频 release() 释放与MediaPlayer对象相关的资源 isPlaying() 判断当前MediaPlayer是否正在播放音频 getDuration() 获取载入的音频文件的时长 AssetManager 类 app/src/main/assets 内的文件和子目录在项目打包时会一并打包到安装文件中。 AssetManager 就是用来管理asset内文件的工具类 音频示例 播放安装包内音频12345678910111213141516171819202122232425262728293031323334353637383940class MainActivity : AppCompatActivity() { private val mediaPlayer = MediaPlayer() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initMediaPlayer() play.setOnClickListener { if (!mediaPlayer.isPlaying) { mediaPlayer.start() // 开始播放 } } pause.setOnClickListener { if (mediaPlayer.isPlaying) { mediaPlayer.pause() // 暂停播放 } } stop.setOnClickListener { if (mediaPlayer.isPlaying) { mediaPlayer.reset() // 停止播放 initMediaPlayer() } } } private fun initMediaPlayer() { val assetManager = assets val fd = assetManager.openFd(\"music.mp3\") mediaPlayer.setDataSource(fd.fileDescriptor, fd.startOffset, fd.length) mediaPlayer.prepare() } override fun onDestroy() { super.onDestroy() mediaPlayer.stop() mediaPlayer.release() }} 视频概论 VideoView 类实际上是在MediaPlayer上的一层封装。 注意VideoView不支持播放asset文件，但可以播放app/src/main/res/raw下的文件（想到VideoView是一种View就不难理解）。 注意VideoView不适合做功能强大的视频播放器。 视频实例 VideoView控件12345&lt;VideoView android:id=\"@id+videoView\" ...layout_width=... ...layout_height=... ... /&gt; VideoView类123456789101112131415161718192021222324252627282930313233/*class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)*/ val uri = Uri.parse(\"android.resource://$packageName/${R.raw.video}\") //留意资源URI字符串格式 videoView.setVideoURI(uri) /* play.setOnClickListener { if (!videoView.isPlaying) { videoView.start() // 开始播放 } } pause.setOnClickListener { if (videoView.isPlaying) { videoView.pause() // 暂停播放 } } replay.setOnClickListener { if (videoView.isPlaying) { videoView.resume() // 重新播放 } } }*/ override fun onDestroy() { super.onDestroy() videoView.suspend()//释放VideoView占用的资源 }} 后台默默劳动者 Service 安卓多线程 Kotlin 多线程编程 kotlin创建线程的三种方式123456789101112131415161718//1. 继承重写Thread()class MyThread: Thread() { override fun run() {...}}MyThread.start()//2-1. 用接口构造Thread()Thread(object: Runnable { //注意这里是匿名内部类的写法 override fun run() {...}}).start()//2-2. kotlin单抽象方法接口の简化版Thread{/*Lambda*/}.start()//3. 用kotlin内置顶层函数thread { //logic} 异步消息处理机制 Android 只能在主线程中改UI，因此在子线程中想要进行UI操作就需要异步机制 Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间传递数据。 Handler主要用于发送和处理消息，发送消息一般是使用Handler的sendMessage()方法、post()方法等，而发出的消息经过一系列地辗转处理后，最终会传递到Handler的handleMessage()方法中。 MessageQueue是消息队列的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象。 Looper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入一个无限循环当中，然后每当发现MessageQueue中存在一条消息时，就会将它取出，并传递到Handler的handleMessage()方法中。每个线程中只会有一个Looper对象。 异步消息处理机制实例123456789101112131415161718192021222324252627class MainActivity : AppCompatActivity() { val updateText = 1 //在主线程中创建一个Handler对象，当接收到Message时该对象的.handleMessage()就能在主线程中被调用 val handler = object : Handler() { override fun handleMessage(msg: Message) { // 在这里可以进行UI操作 when (msg.what) { updateText -&gt; textView.text = \"Nice to meet you\" } } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) changeTextBtn.setOnClickListener { thread { val msg = Message() msg.what = updateText handler.sendMessage(msg) // 在子线程将Message对象发送出去 } } }//一趟下来Message从子线程辗转到了主线程} classDiagram class Message { Int what Int arg1 Int arg2 Object obj } class Handler { +sendMessage(Message m) +post() +handleMessage(Message m)* } Handler --> Message: 发送 Message --> Handler: 处理 AsyncTask 类 重写四个方法，.execute()启动 解析AsyncTask类12345678&lt;A&gt; AsyncTask&lt;paramsType, progressType, resultType&gt; {//注意三个泛型：参数类型 进度类型 结果类型 &lt;A&gt; onPreExecute() //后台开启前的初始化任务 &lt;A&gt; doInBackground(paramsType...) //后台任务：在子线程中运行 &lt;A&gt; onProgressUpdate(progressType...) //后台publishProgress(progressType...)后执行（通常在这改UI） &lt;A&gt; onPostExecute(resultType) //后台return后执行 &lt;+&gt; execute() //启动任务} Service 基础 Service 类 Service类解析123456class Service { onCreate() //创建时调用（第一次&lt;Activity&gt;.startService, bindService） onStartCommand(intent: Intent, flags: Int, startId: Int) //启动时调用(startServi...) onDestroy() //销毁时调用(stopService, unbindService) onBind(): IBinder //返回一个绑定接口便于Activity与Service交互} 创建、启动与销毁 Activity中启动与停止Service1234567startServiceBtn.setOnClickListener { val intent = Intent(this, MyService::class.java) startService(intent) // 启动Service，会同时调用&lt;Service&gt;.onCreate和onStartCommand}stopServiceBtn.setOnClickListener { val intent = Intent(this, MyService::class.java) stopService(intent) // 停止Service Binder 类 继承一个Binder，在类中编写自己的函数，通过onBind() 返回该实例给Activity，Activity中调用该实例的方法以实现Activity与Service的通信 classDiagram class IBinder &lt&ltinterface&gt&gt IBinder class MyBinder { &lt&lt自定义&gt&gt } IBinder |停止服务| stopService+unbindService A(同一个Service类只会存在一个实例) 前台服务 Foreground 前台Service和普通Service最大的区别就在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。 由于状态栏中一直有一个正在运行的图标，相当于我们的应用以另外一种形式保持在前台可见状态，所以系统不会倾向于回收前台Service。 启用方式：在&lt;Service&gt;.onCreat()中创建一条通知，大体上与1.1中创建通知的方式一样，不同的是不用通知管理器发送通知而是以startForeground(…)发送通知。 应用开启前台服务权限12345&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.servicetest\"&gt; &lt;uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\" /&gt; …&lt;/manifest&gt; 前台服务实例12345678910111213141516171819202122class MyService : Service() { … override fun onCreate() { super.onCreate() val manager = getSystemService(Context.NOTIFICATION_SERVICE) asNotificationManager if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { val channel = NotificationChannel(\"my_service\", \"前台Service通知\", NotificationManager.IMPORTANCE_DEFAULT) manager.createNotificationChannel(channel) } val intent = Intent(this, MainActivity::class.java) val pi = PendingIntent.getActivity(this, 0, intent, 0) val notification = NotificationCompat.Builder(this, \"my_service\") .setContentTitle(\"This is content title\") .setContentText(\"This is content text\") .setSmallIcon(R.drawable.small_icon) .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.large_icon)) .setContentIntent(pi) .build() startForeground(1, notification) } …} IntentService 类 classDiagram class IntentService { &lt&ltAbstract&gt&gt onHandleIntent(Intent intent)* } class MyIntentService { &lt&lt自定义&gt&gt } class Service { &lt&ltAbstract&gt&gt } Service","link":"/posts/87cffae2/"},{"title":"技术&#x2F;笔记&#x2F;《第一行代码：Android》读书笔记 (二)","text":"Android Kotlin 读书笔记 简介 \"《第一行代码：Android 3rd》第六章到第八章的读书笔记，主要内容包括Android数据存储（持久化技术），四大组件中的Broadcast广播系统以及ContentProvider内容提供商\" 为方便笔记，约定使用一下伪Kotlin语法： &lt;!ClassName&gt; 用来表示ClassName类的一个实例 &lt;Abstract&gt;或&lt;A&gt; 写在方法(类)前用来表示该方法（类）是一个必须要给出实现的抽象方法 XXX 表示待定的语法字符串 ... 表示前后代码段省略 第六章 全局大喇叭！详解广播机制 监听/接受广播 静态/动态注册BroadcastReciever，注意静态注册的接收器不能接受隐式Intent，还缺乏Activity上下文，但是能够在没启动的情况下收听到广播信号 静态注册：Manifest中注册；动态注册：Activity中注册，要记得自行销毁 发送自定义广播 Intent可以不但可以穿梭于不同Activity之间，也可以穿梭于不同Application之间（Broadcast） 分类：标准广播（一传多），有序广播（one by one，可截断） 第七章 数据存储：告别不持久 Java流基础知识 文件存储 适合存储一些简单的文本数据或二进制数据 Context 类提供 openFileOutput(...), openFileInput(...)用来打开（创建）一个/data/data/&lt;package name&gt;/files/目录下的文件，方法返回一个FileOutPutStream或FileInputStream对象，该对象可使用 Java流 的方式IO 举例：FileOutPut - OutputStreamWriter - BufferedWriter 文件存储实例1234567891011fun save(inputText: String) { try { val output = openFileOutput(\"data\", Context.MODE_PRIVATE) val writer = BufferedWriter(OutputStreamWriter(output)) writer.use { it.write(inputText) } } catch (e: IOException) { e.printStackTrace() }} SharedPreferences 存储 SharedPreferences 是使用键值对的方式来存储数据的，支持多种数据类型的存储 获取SharedPreferences: Context 的 getSharedPreferences() Activity 的 getPreferences() 存储步骤 调用SharedPreferences对象的edit()方法获取一个SharedPreferences.Editor对象。 向SharedPreferences.Editor对象中添加数据，比如添加一个布尔型数据就使用putBoolean()方法，添加一个字符串则使用putString()方法，以此类推。 调用apply()方法将添加的数据提交，从而完成数据存储操作。 KTX库方法： KTX简化SharedPreferences存储1234getSharedPreferences(\"data, Context.MODE_PRIVATE\").edit { putString(\"name\", \"Tom\") putInt(\"age\", 28)} SQLite数据库存储 SQLite 是一种轻量简便的关系型数据库，可以用来存储复杂关系的数据 SQLiteOpenHelper帮助类，借助这个类可以非常简单地对数据库进行创建和升级（需要重写onCreate(), onUpgrate()） 两种CRUD方式：SQLiteDataBase类成员函数；SQL语句执行。 KTX库：contentValuesOf() 方法 数据库文件存储路径：/data/data/&lt;package name&gt;/databases/下 创建数据库 继承一个SQLiteOpenHelper的帮助类 解析SQLiteHelper帮助类12345678910111213141516//构造方案之一SQLiteOpenHelper(context: Context, name: String, cursor: Cursor, version: Int) { // 上下文; 数据库名; 查询数据时用，一般传null; 版本号; /*抽象方法*/ &lt;A&gt; override fun onCreate(db: SQLiteDatabase) { /*创建数据库时（name指定的数据库不存在时）调用*/ } &lt;A&gt; override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) { /*升级数据库时（version改变时）调用*/ } /*两个重要的实例方法*/ getReadableDatabase() getWritableDataBase() //打开（没有则创建）帮助类指定的数据库，返回一个可对数据库进行读写的对象(SQLiteDataBase)。当数据库不可写入时Readable将以只读方式打开，Writable将异常 //注意Kotlin中可以直接调用readableDatabase、writableDataBase属性} 可以使用AS的Device File Explore和Database Navigate插件浏览虚拟机中的文件和数据库 升级数据库 改变SQLiteOpenHelper类的version: Int参数，则下一次打开数据库的时候（用getReadableDatabase() getWritableDataBase()）会调用onUpgrade()方法。 最佳编写方式：针对不同版本编写不同逻辑 最佳实例12345678override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) { if (oldVersion &lt;= 1) { db.execSQL(createCategory) } if (oldVersion &lt;= 2) { db.execSQL(\"alter table Book add column category_id integer\") }} 数据库のCRUD 直接执行 SQL 语句 execSQL()签名12345&lt;!SQLiteDataBase&gt;.execSQL(string: String, array: StringArray)//增删改 sql语句（含占位符）； 参数列表；&lt;!SQLiteDataBase&gt;.rawQuery(string: String, array: StringArray): Cursor//查 sql语句（含占位符）； 参数列表； 使用内置方法 SQLiteDataBase部分方法123456789101112131415161718192021222324252627/*插入*/&lt;!SQLiteDataBase&gt;.insert(tableName: String, null, contentValues: ContentValues)//para2用于给某些为配值的可为空的列自动赋值为NULL；para3：ContentValue对象需要提供一系列put()方法的重载，用于向表中添加数据//ContentValues()构建实例val values1 = ContentValues().apply { // 开始组装第一条数据 put(\"name\", \"The Da Vinci Code\") put(\"author\", \"Dan Brown\") put(\"pages\", 454) put(\"price\", 16.96) } /*修改*/&lt;!SQLiteDataBase&gt;.updata(tableName: String, contentValues: ContentValues, where: String, paraArray: Array) //para3: 相当于sql中的WHERE部分；para4: 给WHERE中占位符分配参数的列表 /*删除*/&lt;!SQLiteDataBase&gt;.updata(tableName: String, where: String, paraArray: Array)/*查找*/&lt;!SQLiteDataBase&gt;.query(...): Cursor 方法的参数列表见下文/*调用query()返回一个Cursor对象*/&lt;!Cursor&gt;.moveToFirst()指针移动到第一个，成功返回True&lt;!Cursor&gt;.moveToNext()移动到下一个，成功返回True&lt;!Cursor&gt;.getXXX(Cursor.getColumnIndex())获取根据索引取出相应类型的值（XXX为某种Type）&lt;!Cursor&gt;.close()关闭指针 query()方法参数 对应SQL部分 描 述 table from table_name 指定查询的表名 columns select column1, column2 指定查询的列名 selection where column = value 指定where的约束条件 selectionArgs - 为where中的占位符提供具体的值 groupBy group by column 指定需要group by的列 having having column = value 对group by后的结果进一步约束 orderBy order by column1, column2 指定查询结果的排序方式 Cursor的更多用法 KTX库简化ContentValues的组装12val values = cvOf(\"name\" to \"Game of Thrones\", \"author\" to \"George Martin\", \"pages\" to 720, \"price\" to 20.85)db.insert(\"Book\", null, values) SQLite 事务 (约定db: SQLiteDataBase) 首先用db.Transaction() 开启事务，之后在try块中编写数据库事务逻辑，结束时调用db.setTransactionSuccessful()，如果事务处理期间抛出异常将被catch捕获，事务将不被处理；如果顺利完成无Exception抛出，则在finally块中调用db.endTransaction()结束事务。 事务实例123456789101112131415161718replaceData.setOnClickListener { val db = dbHelper.writableDatabase db.beginTransaction() // 开启事务 try { db.delete(\"Book\", null, null)// if (true) {// // 在这里手动抛出一个异常，让事务失败// throw NullPointerException()// } val values = cvOf(\"name\" to \"Game of Thrones\", \"author\" to \"George Martin\", \"pages\" to 720, \"price\" to 20.85) db.insert(\"Book\", null, values) db.setTransactionSuccessful() // 事务已经执行成功 } catch (e: Exception) { e.printStackTrace() } finally { db.endTransaction() // 结束事务 } } 第八章 跨程序共享数据，探究 ContentProvider Android 权限机制 普通权限申请：在AndroidManifest.xml中注册即可 普通权限申请12345&lt;manifest ...&gt;...&lt;uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" /&gt;...&lt;/manifest&gt; 运行时权限（危险权限）申请：第一步同普通权限，第二步如下 危险权限申请流程：12345678//检查权限是否以及授予; 权限名（见图8-2）if(ContextCompat.checkSelfPermission(context: Context, permissionName: String) == PackageManager.PERMISSION_GRANTED) {...}//申请权限 权限列表 申请码（标识一次申请）ActivityCompat.requestPermissions(context: Context, permissions: StringArray, code: Int)/*权限申请结果返回时调用*/ /*申请码*/ /*申请的权限列表*/ /*申请结果*/override fun onRequestPermissionsResult (requestcode: Int, permissions: Array&lt;String&gt;, grantResults: IntArray) {...} //申请结果要与PackageManager.PERMISSION_GRANTED比较 Uri 类 内容URI为每一个app的ContentProvider中的数据提供了一个唯一标识符 内容URI字符串由协议声明、authority 和 path 组成（通配符：井号匹配任意长度数字；星号匹配任意长度字符串） 内容URI字符串格式12content://com.example.app.provider/table1/1 ←这是id协议部分 authority（包名.provider） path 解析Uri类1234//内容URI字符串解析为kotlin的Uri对象Uri.parse(uri: String): Uri//按‘/’分割Uri对象的内容URI的Path部分&lt;!Uri&gt;.getPathSegments(): List&lt;String&gt; ContentResover 类 获取实例：通过&lt;!Context&gt;.getContentResolver() ——Kotlin中即contentResolver属性 ContentResolver 的 CURD (将SQLiteDataBase对应的CURD中表名换成Uri即可) ContentProvider 类 ContentProvider实例需要实现其他app访问本app的CURD接口，而ContentResolver只是提供了一个访问其他程序的api；二者CURD 函数参数列表相同。 创建一个ContentProvider组件 使用AS的快捷方式 手动注册AndroidManifest.xml &lt;ContentProvider&gt;组件属性 exported：是否允许外部程序访问 enabled：是否启用 ContentProvider类中有6个抽象方法，我们在使用子类继承它的时候，需要将这6个方法全部重写。 ContentProvider待实现方法1234567891011121314151617181920&lt;A&gt; ContentProvider() { /*初始化ContentProvider的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回true表示ContentProvider初始化成功，返回false则表示失败。*/ override fun onCreate(): Boolean /*从ContentProvider中查询数据。uri参数用于确定查询哪张表，projection参数用于确定查询哪些列，selection和selectionArgs参数用于约束查询哪些行，sortOrder参数用于对结果进行排序，查询的结果存放在Cursor对象中返回。*/ override fun query(uri: Uri, projection: Array&lt;String&gt;?, selection: String?, selectionArgs: Array&lt;String&gt;?, sortOrder: String?): Cursor? /*向ContentProvider中添加一条数据。uri参数用于确定要添加到的表，待添加的数据保存在values参数中。添加完成后，返回一个用于表示这条新记录的URI。*/ override fun insert(uri: Uri, values: ContentValues?): Uri? /*更新ContentProvider中已有的数据。uri参数用于确定更新哪一张表中的数据，新数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行，受影响的行数将作为返回值返回。*/ override fun update(uri: Uri, values: ContentValues?, selection: String?, selectionArgs: Array&lt;String&gt;?): Int /*从ContentProvider中删除数据。uri参数用于确定删除哪一张表中的数据，selection和selectionArgs参数用于约束删除哪些行，被删除的行数将作为返回值返回。*/ override fun delete(uri: Uri, selection: String?, selectionArgs: Array&lt;String&gt;?): Int /*根据传入的内容URI返回相应的MIME类型。*/ override fun getType(uri: Uri): String?} UriMatcher 类：方便匹配 ContentProvider 的 CURD 方法中的Uri（当调用UriMatcher的match()方法时，可以将一个Uri对象传入，返回值是某个能够匹配这个Uri对象所对应的自定义代码，利用这个代码，就可以判断出调用方期望访问的是哪张表中的数据了。） 解析UriMatcher帮助类12345&lt;!UriMatcher&gt;.addURI(autority: String, path: String, code: Int)//添加匹配规则 返回代码（唯一标识匹配规则）&lt;!UriMatcher&gt;.match(uri: Uri): Int// 匹配对象 返回代码 MIME 字符串格式： 必须以vnd开头。 如果内容URI以路径结尾，则后接android.cursor.dir/；如果内容URI以id结尾，则后接android.cursor.item/。 最后接上vnd.&lt;authority&gt;.&lt;path&gt;。 MIME示例12345URI: content://com.example.app.provider/table1MIME: vnd.android.cursor.dir/vnd.com.example.app.provider.table1 URI: content://com.example.app.provider/table1/1MIME: vnd.android.cursor.item/vnd.com.example.app.provider.table1","link":"/posts/c484d1a3/"},{"title":"技术&#x2F;笔记&#x2F;《第一行代码：Android》读书笔记 (一)","text":"Android Kotlin 读书笔记 简介 \"《第一行代码：Android 3rd》第一章到第五章的读书笔记，讲了AS的基本使用方法和Android项目结构，四大组件之一的Activity，以及各种UI控件的编写，还收录了本书中涉及的Kotlin的语法特性\" 第一章 开启征程（概要） 项目结构与目录：page 17 - page 19 Log 方法与 Logcat 的完美结合 第二章 Kotlin 语法糖 同《Kotlin 学习笔记》一同食用更佳！ 《第一行》中出现的 Kotlin 特性预览表 主次构造函数 参数默认值 键值对传参 字符串内嵌表达式 init {}, constructor () {} fun xxx(str: String = &quot;&quot;) {...} xxx(str = &quot;...&quot;) &quot;${value}&quot; 标准函数 Lambda 表达式 空指针检查 函数式 API let, run, apply, with {para -&gt; ...}, {it.toString()} ? ?. !!. ?: map.maxby {/*Lambda*/} 容器初始化 数据类 单例类 循环遍历 listOf(), mapOf(), setOf() data object for-in, until, downTo, step, l...r, 容器遍历 分支控制 条件控制 “不变为先” 访问控制 when () {... -&gt; ...}, if-else 语句/表达式 is (instanceof), else val, var, open class &quot;public by default&quot; 类型强转 repeat 函数 运算符重载 延迟初始化 as, as? repeat(/*num*/) {/*Lambda*/} operator 关键字 lateinit 初始化判断 密封类（与when语句一同使用） 扩展函数 无用参数 ::($变量名).isInitialized sealed class fun ClassName.funcName(...) : ... {} 下划线_ 函数类型 高阶函数 内联函数 可变参数 ClassName.(paraType, ...) -&gt; returnType 接受/返回函数类型/Lambda表达式的函数 inline noinline crossinline vararg Pair 类型 Smart Cast 自动转型 泛型 委托 A to B， 泛型 is Type 判断后实例自动向下转换类型 &lt;T&gt; 类委托、属性委托 第三章 Activity！所见即所得 创建 Activity 创建和加载布局文件 layout 在 AndroidManifest.xml 中注册Activity 编写 Activity.kt 代码 （事件绑定，方法重写等） Activity 通信与切换 Intent 类 显式切换：Intent(上下文, 指定Activity 的 Class 类) 隐式切换：指定 action category，目标将会按照注册信息中的过滤条件响应 intent。 过滤条件：&lt;category&gt; &lt;action&gt; &lt;data&gt; 传参：.putExtra(), .getStringExtra() 启动方式：startActivity() //普通启动 startActivityForResult() //请求结果 - Activity 类 Result 结果 设置结果：setResult() 取回结果：override onActivityResult() Bundle 类 团队合作时用伴生类“静态方法”来启动 Activity 生命周期 返回栈的概念 思维导图 保存信息 Bundle 类型 onSaveInstanceState()，var savedInstanceState Activity 启动模式 standard 无检查，直接压栈 singleTop 检查栈顶 singleTask 解栈恢复 singleInstance 创建新栈 第四章 UI！！ 门面功夫 😃 控件 Widget 基本控件：TextView，EditView，Button，…… 自定义控件：编写class（注入布局，绑定事件）→\\rightarrow→ xml注册引入自定义控件 →\\rightarrow→ 引入控件 高级一点的控件：ListVIew, RecyclerView … 基本原理撇清楚 Inflater 的作用：将xml格式的布局文件解析转化成View的实例 findViewById() 返回布局中指定id的View实例, 在Activity类中直接使用findViewById()相当于在当前Activitiy所加载的布局中寻找对应的view，而使用view.findViewById()则指定了寻找的区域是view内 留意Kotlin自动类型推导机制的使用场合，方法 *第五章 手机平板要兼顾，探究Fragment 学习内容 Frag 生命周期，Frag 动态加载布局","link":"/posts/37a431d8/"},{"title":"算法&#x2F;序列标注之HMM与CRF模型","text":"机器学习 HMM CRF 绪论 ​ 从文本翻译到文字、语音识别，再到命名实体识别，词性标注，序列标注问题已然渗透到社会生活中的方方面面。不少自然语言处理的问题都可以想方设法转化为序列标注问题：对邮件等”大块“的信息做命名实体识别，识别出信息中的表单项用于自动填写表单，可以有效地提高工作效率，节约时间；对音频文件进行标注分析，可以用来进行语音识别；抽取出来的电子病历文本中的疾病、治疗、检查等类型的实体，可以用以对电子病历进行分类归档…想要处理好一般性的自然语言处理问题到序列标记问题的转化，关键在于处理好如何定义标记的问题。 ​ 作为自然语言处理中常见的问题之一，序列标注问题已经由来已久，并在经历了一系列的发展变革后逐渐壮大健全。最早的有传统的隐马尔可夫模型、最大熵模型和条件随机场模型，最大熵模型抛弃了隐马尔科夫模型的独立输出假设，而条件随机场模型又在最大熵模型的基础上进一步将标签的转移扩大为全局特征，使得上下文之间的联系更加紧密。无论是在理论还是实践结果上来看，条件随机场的整体效果都要优于前两种方法。步入深度学习发展的时代后，新的诸如RNNRNNRNN和LSTMLSTMLSTM模型也相继用于序列标注问题，有效地改善了传统方法在处理更长的上下文依赖、过拟合、依赖启发式知识等方面的不足之处。本文主要研究和探讨了传统的序列标注模型——隐马尔可夫模型和条件随机场模型——的理论基础和应用实践。 正文 定义 ​ 序列标注是指将输入的一串观测序列 x1x2x3...xnx_1x_2x_3...x_nx1​x2​x3​...xn​ 转化为一串标记序列 y1y2y3...yny_1y_2y_3...y_ny1​y2​y3​...yn​ 的过程，要解决序列标记问题，实际上就是要找到一个观测序列到标记序列的映射 f(xi)→yi (i=1,2,...,n)f(x_i)\\rightarrow y_i\\space (i=1,2,...,n)f(xi​)→yi​ (i=1,2,...,n)。 HMM模型 马尔可夫链 马尔可夫链（Markov chain）1，又称离散时间马尔可夫链，为状态空间中经过从一个状态到另一个状态的转换的随机过程。该过程要求具备“无记忆”的性质：下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。 ​ 从数学形式上来看，对于随机变量序列X1X2X3...XnX_1X_2X_3...X_nX1​X2​X3​...Xn​，满足 P(Xn=xn∣X1=x1,X2=x2,X3=x3...,Xn−1=xn−1)=P(Xn=xn∣Xn−1=xn−1)P(X_n=x_n|X_1=x_1,X_2=x_2,X_3=x_3...,X_{n-1}=x_{n-1})=P(X_n=x_n|X_{n-1}=x_{n-1}) P(Xn​=xn​∣X1​=x1​,X2​=x2​,X3​=x3​...,Xn−1​=xn−1​)=P(Xn​=xn​∣Xn−1​=xn−1​) ，则称该序列为一个一阶马尔可夫链。 ​ 从宏观意义上来看，Markov链说明了在状态转移过程中，“未来”与“过去”无关而只与“现在”有关。 ​ Markov链常常被认为是时齐的，即转移概率与n无关。 ​ 类似的可以定义m阶Markov链，满足 P(Xn=xn∣X1=x1,X2=x2,X3=x3...,Xn−1=xn−1)=P(Xn=xn∣Xn−m=xn−m,Xn−m+1=xn−m+1...,Xn−1=xn−1)\\begin{aligned} &amp;P(X_n=x_n|X_1=x_1,X_2=x_2,X_3=x_3...,X_{n-1}=x_{n-1})\\\\ =&amp;P(X_n=x_n|X_{n-m}=x_{n-m},X_{n-m+1}=x_{n-m+1}...,X_{n-1}=x_{n-1}) \\end{aligned} =​P(Xn​=xn​∣X1​=x1​,X2​=x2​,X3​=x3​...,Xn−1​=xn−1​)P(Xn​=xn​∣Xn−m​=xn−m​,Xn−m+1​=xn−m+1​...,Xn−1​=xn−1​)​ 隐马尔可夫模型 ​ 隐马尔可夫模型（Hidden Markov Model 缩写：HMM）基于Markov链，不同与一般的Markov链，HMM 又加入了隐变量这一概念，即该模型包含了观测序列X1X2X3...XnX_1X_2X_3...X_nX1​X2​X3​...Xn​和与它一一对应的标记序列Y1Y2Y3...YnY_1Y_2Y_3...Y_nY1​Y2​Y3​...Yn​。该模型用到了两个基本假设： 时齐的Markov性假设，如2.2.1所述 独立输出假设，输出状态的概率仅与输入状态相关，而与输入序列的前后文无关 以图形表示的隐马尔可夫模型如下所示： HMM 模型解决了被用来解决序列标注问题中的三个基本问题：预测、平滑和解码。本文主要讨论的解码问题，即求解给定观测序列，给出最有可能的标记序列的问题。本文使用λ(W,T,π,β,A,B)\\lambda(W,T,\\pi,\\beta,A,B)λ(W,T,π,β,A,B)来表征一个序列标注问题的HMM模型，其中WWW表示观测序列，TTT表示输出的标记序列，π\\piπ表示标记之间的概率转移转移矩阵，β\\betaβ表示标记到观测值的发射概率，AAA表示输入对象的集合，BBB表示标记的集合。 概率模型 问题归结于求解下式 argTmax P(T=t1t2...tn∣W=w1w2...wn,λ)(ti∈B,wi∈A)(1)arg_{T}max\\space P(T=t_1t_2...t_n|W=w_1w_2...w_n,\\lambda)\\qquad (t_i\\in B, w_i\\in A)\\tag{1} argT​max P(T=t1​t2​...tn​∣W=w1​w2​...wn​,λ)(ti​∈B,wi​∈A)(1) 由贝叶斯概率公式 P(T∣W)=P(W∣T)P(T)P(W)∝P(W∣T)P(T)(2)P(T|W)=\\frac{P(W|T)P(T)}{P(W)}\\propto P(W|T)P(T)\\tag{2} P(T∣W)=P(W)P(W∣T)P(T)​∝P(W∣T)P(T)(2) 因为 P(W)=constP(W)=constP(W)=const 故而可以省略不予以考虑 由独立输出假设可知 P(W∣T)=P(w1∣t1)P(w2∣t2)...P(wn∣tn)(3)P(W|T)=P(w_1|t_1)P(w_2|t_2)...P(w_n|t_n)\\tag{3} P(W∣T)=P(w1​∣t1​)P(w2​∣t2​)...P(wn​∣tn​)(3) 由一阶时齐的Markov性假设可知 P(T)=P(t1)P(t2∣t1)P(t3∣t2)...P(tn∣tn−1)(4)P(T)=P(t_1)P(t_2|t_1)P(t_3|t_2)...P(t_{n}|t_{n-1})\\tag{4} P(T)=P(t1​)P(t2​∣t1​)P(t3​∣t2​)...P(tn​∣tn−1​)(4) 联立方程 (2)(3)(4)⇒(2)(3)(4)\\Rightarrow(2)(3)(4)⇒ P(T∣W)∼[P(t1)P(w1∣t1)][P(t2∣t1)P(w2∣t2)]...[P(tn∣tn−1)P(wn∣tn)](5)P(T|W)\\sim [P(t_1)P(w_1|t_1)][P(t_2|t_1)P(w_2|t_2)]...[P(t_n|t_n-1)P(w_n|t_n)]\\tag{5} P(T∣W)∼[P(t1​)P(w1​∣t1​)][P(t2​∣t1​)P(w2​∣t2​)]...[P(tn​∣tn​−1)P(wn​∣tn​)](5) 其中转移概率由条件概率公式可知 P(ti∣ti−1)=P(ti,ti−1)P(ti−1)(6)P(t_i|t_{i-1})=\\frac{P(t_i,t_{i-1})}{P(t_{i-1})}\\tag{6} P(ti​∣ti−1​)=P(ti−1​)P(ti​,ti−1​)​(6) 等式(6)(6)(6)中标记值的概率和等式(5)(5)(5)中的独立输出概率可由统计方法或规则方法得出，下面介绍两种方法的异同： 项目 统计方法 规则方法 介绍 通过统计得出频率估计概率的方法 通过既定的规则来估计概率的方法 优点 覆盖面广，稳定性高 精确，对于特殊现象的支持度好 缺点 对于特殊现象的支持度差 规则库庞大，编写和维护复杂，覆盖面不及统计方法 能够计算出特定T∗T^*T∗的概率值P(T∗∣W)P(T^*|W)P(T∗∣W)还不够，还要要找到最大的概率对应的TTT。这个问题可以转化成一个求解最短加权路径的图论问题。 可构建像 graph 1 所示的图模型（其余路径未画出）。显然，如果标记的取值有mmm种可能，序列的长度为nnn，那么枚举所有路径然后取加权值最大的路径的算法复杂度为 O(nm)O(n^m)O(nm) ，随着序列长度增长而呈指数级增长。为了降低复杂度这里一般采用维特比算法 (Viterbi algorithm) 。 The Viterbi algorithm2 is a dynamic programming algorithm for finding the most likely sequence of hidden states—called the Viterbi path—that results in a sequence of observed events, especially in the context of Markov information sources and hidden Markov models (HMM). 维特比算法是一种动态规划算法，用于找出隐藏的最大可能路径（维特比路径）。维特比算法的核心思想在于全局最优包含局部最优。考虑从起点到某个中间点的最大加权路径，那么该路径所经过的该中间点的前一个点在同时间上所有点中也一定是加权最大的点。下面给出了Viterbi算法的伪代码。其中T1,T2T_1,T_2T1​,T2​分别为保存当前节点最大累计权值的矩阵和保存该节点最大累计权值路径上的上一个节点的矩阵。以下给出了维特比算法的算法伪代码： 下溢问题：(5)(5)(5) 式中的连乘积中因子有可能过小而下溢为零从而造成整个式子变为0，为了避免这种情况可以考虑取对数化乘积为加法的技巧。 应用 ​ 绝大多数自然语言处理问题（Natural Language Processing Problem，简称NLP问题），都可以转化为一个序列标注问题。想要处理好NLP问题到序列标记问题的转化关键在于处理好如何定义标记的问题。例如对于中文分词问题，可以定义标签集合 T={B,M,E,S}T=\\{B,M,E,S\\}T={B,M,E,S} ，其中 B(begin),M(middle),E(end),S(single)B(begin),M(middle),E(end),S(single)B(begin),M(middle),E(end),S(single) 分别表示词的开头，中间，结尾和单个字成词；对于词性标注问题，可以在分词处理的基础上让一个词对应一个词性标签。对于命名实体识别问题，可以定义标签集合 T={BL,ML,EL,BP,MP,EP,BO,MO,EO,N}T=\\{BL,ML,EL,BP,MP,EP,BO,MO,EO,N\\}T={BL,ML,EL,BP,MP,EP,BO,MO,EO,N} 其中 B,M,EB,M,EB,M,E 后面跟着的 L(location),P(person),O(organization)L(location),P(person),O(organization)L(location),P(person),O(organization) 分别表示地名，人民，机构名，而 NNN 表示不属于实体的部分。定义好标记之后输入训练好的模型后问题即可求解。 CRF 模型 随机场、马尔可夫随机场、条件随机场 ​ 考虑一个空间内各个区域按照某种分布被赋予了某个随机值，这样的场称之为“随机场”。而马尔可夫随机场则是一类特殊的随机场，场中每个点的赋值不仅与自身位置有关，还和相邻位置的赋值相关。如果考虑马尔科夫性的同时将点的赋值概率看做是条件概率，则称该马尔科夫场为条件随机场（Conditional random fields 简称：CRF）。如维基百科3中所述: Whereas a classifier predicts a label for a single sample without considering “neighboring” samples, a CRF can take context into account. ​ CRF模型和那些仅仅只考虑自身来进行分类的模型不同之处就在于CRF模型将样本点的“邻居”也考虑在内，这个特点使得CRF模型有能力处理上下文有关联的序列标注的问题。 线性链条件随机场 线性链的条件随机场（Linear conditional random fields）是对条件随机场的简化模型：X=(X1,X2,...Xn),Y=(Y1,Y2,...Yn)X=(X1,X2,...Xn),Y=(Y1,Y2,...Yn)X=(X1,X2,...Xn),Y=(Y1,Y2,...Yn) 均为线性链表示的随机变量序列，在给定随机变量序列XXX的情况下，随机变量YYY的条件概率分布 P(Y∣X)P(Y|X)P(Y∣X) 构成条件随机场，即满足马尔科夫性： P(Yi∣X,Y1,Y2,...Yn)=P(Yi∣X,Yi−1,Yi+1)(7)P(Yi|X,Y1,Y2,...Yn)=P(Yi|X,Yi−1,Yi+1)\\tag{7} P(Yi∣X,Y1,Y2,...Yn)=P(Yi∣X,Yi−1,Yi+1)(7) 则称 P(Y∣X)P(Y|X)P(Y∣X) 为线性链条件随机场。 概率模型 ​ 为了建立可供学习的CRF模型，可以定义两类特征函数（这些特征函数用来评价一个序列在某些特征方面是否“靠谱”，只有 1,01, 01,0 两种取值，即判断是否满足条件）：一类只与当前节点有关，表示为sl(yi,x,i) (l=1,2...,m)s_l(y_i,x,i)\\space (l=1,2...,m)sl​(yi​,x,i) (l=1,2...,m)；另一类还与前一个节点有关，表示为tk(yi−1,yi,x,i) (k=1,2...,n)t_k(y_{i-1},y_i,x,i)\\space (k=1,2...,n)tk​(yi−1​,yi​,x,i) (k=1,2...,n)。引入需要学习的权重参数（所谓“权重”即用来衡量一个判断依据的重要程度的参数）λl,μk\\lambda_l,\\mu_kλl​,μk​，则条件概率表示为 P(y∣x)=1Z(x)exp(∑i,kλktk(yi−1,yi,x,i)+∑i,lμlsl(yi,x,i))∝exp(∑i,kλktk(yi−1,yi,x,i)+∑i,lμlsl(yi,x,i))(8)\\begin{aligned} P(y|x)&amp;=\\frac{1}{Z(x)}exp(\\sum_{i,k}λ_kt_k(y_{i−1},y_i,x,i)+\\sum_{i,l}μ_ls_l(y_i,x,i))\\\\ &amp;\\propto exp(\\sum_{i,k}λ_kt_k(y_{i−1},y_i,x,i)+\\sum_{i,l}μ_ls_l(y_i,x,i)) \\end{aligned}\\tag{8} P(y∣x)​=Z(x)1​exp(i,k∑​λk​tk​(yi−1​,yi​,x,i)+i,l∑​μl​sl​(yi​,x,i))∝exp(i,k∑​λk​tk​(yi−1​,yi​,x,i)+i,l∑​μl​sl​(yi​,x,i))​(8) Z(x)Z(x)Z(x)为规范化因子，是所有可能的标注序列的概率和，使得等式右边规范为一个概率。 Z(x)=∑yexp(∑i,kλktk(yi−1,yi,x,i)+∑i,lμlsl(yi,x,i))(9)Z(x)=\\sum_{y}exp(\\sum_{i,k}λ_kt_k(y_{i−1},y_i,x,i)+\\sum_{i,l}μ_ls_l(y_i,x,i))\\tag{9} Z(x)=y∑​exp(i,k∑​λk​tk​(yi−1​,yi​,x,i)+i,l∑​μl​sl​(yi​,x,i))(9) 为了使得表示更加方便，将参数 λ,μ\\lambda,\\muλ,μ 均表示为 www ，特征函数 t,st, st,s 均表示为 fff ，即有 wk={λk(0&lt;k⩽m)μk−m(m&lt;k⩽m+n)(10)w_{k}=\\left\\{ \\begin{aligned} &amp;\\lambda_k\\qquad &amp;(0 &lt; k \\leqslant m)\\\\ &amp;\\mu_{k-m}\\qquad &amp;(m &lt; k \\leqslant m+n) \\end{aligned}\\tag{10} \\right. wk​={​λk​μk−m​​(0&lt;k⩽m)(m&lt;k⩽m+n)​(10) fk(y,x)={∑isk(yi,x,i)(0&lt;k⩽m)∑itk−m(yi−1,yi,x,i)(m&lt;k⩽m+n)(11)f_{k}(y,x)=\\left\\{ \\begin{aligned} &amp;\\sum_{i}s_k(y_i,x,i)\\qquad &amp;(0 &lt; k \\leqslant m)\\\\ &amp;\\sum_{i}t_{k-m}(y_{i-1},y_i,x,i)\\qquad &amp;(m &lt; k \\leqslant m+n) \\end{aligned}\\tag{11} \\right. fk​(y,x)=⎩⎪⎪⎪⎨⎪⎪⎪⎧​​i∑​sk​(yi​,x,i)i∑​tk−m​(yi−1​,yi​,x,i)​(0&lt;k⩽m)(m&lt;k⩽m+n)​(11) 由 (11)(12)(11)(12)(11)(12) 式可将 (8)(8)(8) 式简化为 P(y∣x)=exp(∑kwkfk(y,x))∑yexp(∑kwkfk(y,x))∝exp(∑kwkfk(y,x))(12)P(y|x)=\\frac{exp(\\sum_k w_kf_k(y,x))}{\\sum_yexp(\\sum_k w_kf_k(y,x))}\\tag{12} \\propto exp(\\sum_k w_kf_k(y,x)) P(y∣x)=∑y​exp(∑k​wk​fk​(y,x))exp(∑k​wk​fk​(y,x))​∝exp(k∑​wk​fk​(y,x))(12) 参数学习 以下采用梯度下降法来训练参数。 定义损失函数 L=−M=−log∏x,yP(y∣x)P‾(x,y)=−∑x,yP‾(x,y)logP(y∣x)=∑xP‾(x)logZ(x)−∑x,yP‾(x,y)∑kwkfk(y,x)=∑xP‾(x)log∑yexp(∑kwkfk(y,x))−∑x,yP‾(x,y)∑kwkfk(y,x)(13)\\begin{aligned} L&amp;=-M\\\\ &amp;=-log\\prod_{x,y}P(y|x)^{\\overline{P}(x,y)}\\\\ &amp;=-\\sum_{x,y}\\overline{P}(x,y)logP(y|x)\\\\ &amp;=\\sum_{x}\\overline{P}(x)logZ(x)-\\sum_{x,y}\\overline{P}(x,y)\\sum_k w_kf_k(y,x)\\\\ &amp;=\\sum_{x}\\overline{P}(x)log\\sum_{y}exp\\big(\\sum_k w_kf_k(y,x)\\big)-\\sum_{x,y}\\overline{P}(x,y)\\sum_k w_kf_k(y,x) \\end{aligned}\\tag{13} L​=−M=−logx,y∏​P(y∣x)P(x,y)=−x,y∑​P(x,y)logP(y∣x)=x∑​P(x)logZ(x)−x,y∑​P(x,y)k∑​wk​fk​(y,x)=x∑​P(x)logy∑​exp(k∑​wk​fk​(y,x))−x,y∑​P(x,y)k∑​wk​fk​(y,x)​(13) 其中P‾\\overline{P}P为先验概率，可以通过统计方法得出。 对损失函数求导可得： ∂L∂wk=∑x,yP‾(x)P(y∣x)fk(y,x)−∑x,yP‾(x,y)fk(y,x)(14)\\frac{\\partial L}{\\partial w_k}=\\sum_{x,y}\\overline{P}(x)P(y|x)f_k(y,x)-\\sum_{x,y}\\overline{P}(x,y)f_k(y,x)\\tag{14} ∂wk​∂L​=x,y∑​P(x)P(y∣x)fk​(y,x)−x,y∑​P(x,y)fk​(y,x)(14) 有了损失函数的导数之后就可以进行迭代优化参数，直到达到收敛条件： wk:=wk−η⋅∂L∂wk(15)w_k:=w_k-\\eta\\cdot\\frac{\\partial L}{\\partial w_k}\\tag{15} wk​:=wk​−η⋅∂wk​∂L​(15) 梯度下降法的算法流程为：定义损失函数 L(w)L(w)L(w)、学习率 η→\\eta\\rightarrowη→计算梯度 ∂L∂wk→\\frac{\\partial L}{\\partial w_k}\\rightarrow∂wk​∂L​→更新 w→w\\rightarroww→计算梯度 ∂L∂wk→\\frac{\\partial L}{\\partial w_k}\\rightarrow∂wk​∂L​→更新 w→...→w\\rightarrow...\\rightarroww→...→达到收敛条件，得到训练后参数 www 同样的，将训练好的CRF模型用于解码问题也可以采用维特比算法，此处将不再赘述。 1.维基百科中文：马尔科夫链 ↩2.wikipedia: Viterbi algorithm ↩3.wikipedia: Conditional_random_field ↩","link":"/posts/568ec988/"},{"title":"算法&#x2F;算法启蒙","text":"算法 写在前面：“学好程序与算法，走遍天下都不怕。” 枚举 背景 找不到合适的数学公式和技巧 （改良后）枚举复杂度不是特别大 通常用于找到一种情况使之满足题意的题目 配合假设法找到目标情形：假币问题 技巧 跳跃枚举法：跳过对没有必要的情况的枚举 局部枚举法：枚举局部，剩下的由该局部确定。例如熄灯问题 递归 作用 替代多重循环，如：n皇后问题。 这种类型往往要运用到一个全局/静态变量来存储前面算过的结果，譬如n皇后就用到了一个全局数组来保存每一行的皇后拜访情况。全局/静态变量的好处就在于所有递归函数共享成果，就像递推迭代一样，每一步会影响下一步。 递归函数形式：T function( T f(n) )，函数意义：在前n-1步已经完成的情况下决定如何走第n步，往往第一个被调用的function参数为0或1（然后依次调用 111 ~ n0n_0n0​） 解决实质是递归形式的问题 有些问题本身就是递归定义的，比如不少表达式就是递归定义的：逆波兰，四则运算。逆波兰直接递归调用自身定义，四则运算则包含项，因子和表达式自身等多个概念，是一种间接递归调用自身定义 函数，数列的递推公式 关键是搞清楚问题是怎样递归定义的，可以借助画图，写代数式的办法捋清楚。 将问题分解为规模更小的子问题来求解 如何来分解？ “n=1+(n-1)”法 比方说要解决一个规模为n的问题，先找到解决该问题的第一步怎么做，然后再把剩下的问题解决，剩下的问题规模刚好是n-1且解决过程自相似，可以用上递归n-1。e.g.台阶问题 “n=(n-1)+1”法 先解决n-1问题，再将最后一步完善,e.g.汉诺塔问题 与多重循环不同，该方法第一个调用的function参数往往时n0总规模 与分治不同，分治往往偏向于均分，而且多了一步综合，不过分治与递归又可以相互补充 附注 atof（）函数，将浮点串转变为浮点数 cin.peek（）函数，提前预知输入而非读取 浮点数的比较引入eps 二分 简介 对一个待求系统（通常为有序系统），每次都均分为两半，通过判断“砍掉”其中“无用”的一半，对剩下的一半用同样的方法处理，直到得出结论。 作用 二分查找 不仅限于查找某一个具体的数，还可以查找符合某种要求的数（通常满足一定的大小关系） 二分法求方程根 分治 基本思想 将一个问题拆分成两个或两个以上规模更小的问题，然后将小问题分别解决或只解决部分问题，最后综合处理一次。 一般模式：分划，局部处理，综合处理（分治 | 归并） 常常与递归思想结合 作用：使规模缩小，提高算法效率（想想：不断地递归并分治，使得规模不断二分） 应用举例：基于分治策略的快速排序和归并排序 附注 &quot; x &amp; 1 &quot; 表达式判别x奇偶性 快速幂算法 动态规划 背景 问题具有最优子结构 问题的最优解所包含的子问题的解也是最优的 问题具有无后效性 当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取何种手段或经过哪条路径演变到当前的这若干个状态，没有关系。 单纯的递归会导致大量子问题 重复计算 时 思路方法 原问题分解为子问题 一些问题的求解归结于它的子问题的求解，且子问题与原问题类似，只是规模减小。 子问题一旦解决即被保存（通常存入一个多维数组）。 确定状态 “状态”简介：在用动态规划解题时，我们往往将和子问题相 关的各个变量的一组取值，称之为一个“状态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状态”所对应的子问题的解。 状态空间与时间复杂度：整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。（在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。） 用动态规划解题，经常碰到的情况是，K个整型变量能 构成一个状态（如数字三角形中的行号和列号这两个变量 构成“状态”）。如果这K个整型变量的取值范围分别是 N1, N2, ……Nk，那么，我们就可以用一个K维的数组 array[N1] [N2]……[Nk]来存储各个状态的“值”。这个 “值”未必就是一个整数或浮点数，可能是需要一个结构 才能表示的，那么array就可以是一个结构数组。一个 “状态”下的“值”通常会是一个或多个子问题的解。 确定一些初始状态（边界状态）的值 确定状态转移方程 将第一步 分解 得到的原问题与子问题的关系用数学符号语言表述出来，即实现状态之间的转移关系。 动规程序写法 记忆递归型 递归函数+记忆数组 “人人为我”递推型 1,2,3,…,n-1 =&gt; n 递推到“n”时“n”仍未被求出，前面已被求出的状态值用于求“n”的状态值 “我为人人”递推型 n =&gt; k (k&gt;n) 递推到“n”时“n”已经被求出，n将用于求后面的状态值 递归写法 递推写法 难度 直观简便 较复杂，可能需要结合图形理解 内存占用 较大，有爆栈风险 小，还可以用滚动数组进一步节省空间 动规中递归法向递推法转化的一般方法： 递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值 是递归函数的返回值，这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。 常见分解（状态转移）方法归纳 多分类讨论， 想想解决原问题等同于解决什么和什么。有时候要经过多层分解才能够得到与原问题结构相同的子问题。 “n=(n-1)+1”型与&quot;n=1+(n-1)&quot;型（与 递归 的 先走一步 思想又异曲同工之妙，n为问题规模） &quot;F(i,j,k)=F(i-1,j,k)+F(i,j-1,k)+F(i,j,k-1)&quot;型（这里拿 三维 的情况举例，其他维度的状态转移方程与此大同小异） &quot;F(m,n)=A, A=G( F(m-1,n),F(m,n-1) )&quot;型，间接递归 附注 数字三角形题目启示录： ①空间优化：滚动数组（通过覆盖今后无用的旧有数据空间的方法来压缩空间），降维，关注不必要的存储空间以及运行过程中变得可以丢弃的数据。②递归化递推：逆向思维。 深度优先搜索 关键词：回溯 标记(判重) 剪枝 图 状态 简介 从某个起点开始每走一步就做一个标记，然后下一步随便选择一个没有走过的节点，走不通则回退到上一步重新选择。这种走法总是试图“走的更远”。 重要概念 图（连通图，非连通图，子图，极大连通子图…） 图上节点（或者某抽象的状态：e.g.譬如每个棋局也可以看作是一个图节点） 图上边：节点之间的联系 图路径（枝） 图的表示 邻接矩阵：L[i][j] 用一个二维数组（元素可以是一个结构，存储诸如 连通与否 路径长度 权值 方向 等内容）表示节点i与节点j之间的联系。遍历复杂度：O(n^2),n表示节点 。 邻接表：S[k] 用一个一维数组（元素可以是一个结构，存储 邻接节点 以及诸如 路径长度 权值 方向 等内容）表示所有与节点k有关的边的信息。遍历复杂度：O(n+e),n表示节点数，e表示边数。 当e特别大而接近n^2时，邻接表就失去了优势变得和邻接矩阵差不多了。 其他表示方法：具体问题具体分析。 剪枝 可行性剪枝：每搜索一个节点后发现不满足题目要求则直接回溯防止沿着这条路径继续错误地走下去。 最优性剪枝：每搜索一个节点后都对当前路径的最优性进行检验，若当前以及可以判明不是最优路径或者说接着走下去一定不是最优路径则直接回溯。 与整体最优解比较来剪枝 保存中间结果用于最优性剪枝 ：如果到达某个状态A时，发现前面曾经也到达过A，且前面那次到达A所花代价更少，则剪枝。这要求保存到达状态A的到目前为止的最少代价。 （ 对每个节点都开辟存储空间来存放以该节点为终点的当前最优解，每次搜索到一个节点就将该最优值与新值比较，原值更优则剪枝，新值更优则更新该最优值） 注意：“最优”的决定要素可能不止一项，还可能是多元因素，如：ROADS问题中有费用和路程两个因素。剪枝时要考虑控制单一变量。 广度优先搜索 简介 从节点开始层次遍历（用队列）整个图。 特点 搜到的路径一定是最短的。 占用空间较大，尤其是目标节点层次很高时。 如果题目要求路径则每次入队的元素都要包含有指向父节点的“指针”。要注意，STL中的queue容器中元素一旦出队则会导致对象的丢失，因此需要自己动手编写一个保证父节点不会丢失的队列。 一般模式 广度优先搜索算法如下：（用QUEUE） 把初始节点S0放入Open表中 如果Open表为空，则问题无解，失败退出 把Open表的第一个节点取出放入Closed表，并记该节点为n 考察节点n是否为目标节点。若是，则 得到问题的解，成功退出 若节点n不可扩展，则转第(2)步 扩展节点n，将其不在Closed表和 Open表中的子节点(判重）放入Open表的尾 部，如有必要为每一个子节点设置指向父节点的指针 (或记录节点的层次），然后转第(2)步。 DSP vs BSP 深搜 广搜 适用范围 几乎任何问题 状态表示比较简单，求最优策略的问题 优点 空间占用较少 找到的解一定路径最短 缺点 运气不好时耗时长，甚至无法在多项式时间内求解，需要剪枝优化 目标节点层次高时搜索过程将产生许多无用节点，搜索效率低且占用空间大，需要优化存储方式 结构 栈（递归） 队列 根据题目要求凭借自己的经验和对两个搜索的熟练程度做出选择 贪心 简介 只考虑当前最优，通过局部最优达到整体最优的策略 贪心算法需要证明其正确性 贪心检验：替换法 假设最优序列为{ai}，贪心得到的序列为{bi}，则只需要证明{ai}={bi}即可证明贪心得到的是整体最优。 必要时先将ai按照bi（贪心策略得到的序列）的方式排好序 然后从i=1开始逐个考虑能否将ai替换为bi而不影响ai后面序列的选择。如果对于所有i均可替换，则{ai}={bi}。 数学归纳法 附注 一类常见的应用贪心策略的题：区间题 解决思路：关注端点，合理排序，顺序处理","link":"/posts/8ee1a4a1/"},{"title":"技术&#x2F;笔记&#x2F;MapReduce实战","text":"MapReduce 实现贝叶斯分类器 理论基础 朴素贝叶斯公式求后验概率 P(ci∣d)=P(d∣ci)P(ci)P(d)P(c_i|d)=\\frac{P(d|c_i)P(c_i)}{P(d)} P(ci​∣d)=P(d)P(d∣ci​)P(ci​)​ 其中 ddd 为文档，cic_ici​ 为分类。文档是词的合集，提取特征 d=&lt;t1,t2,...,tn&gt;d=&lt;t_1, t_2, ... ,t_n&gt;d=&lt;t1​,t2​,...,tn​&gt;，即文档由n个词 token（可重复）组成。做独立性假设后公式可化简为： P(ci∣d)=∏j=1nP(tj∣ci)P(ci)P(d)P(c_i|d)=\\frac{\\prod_{j=1}^{n} P(t_j|c_i)P(c_i)}{P(d)} P(ci​∣d)=P(d)∏j=1n​P(tj​∣ci​)P(ci​)​ 由于需要知道的是文档最有可能的分类，因此实际上是求 arg⁡max⁡ciP(ci∣d)\\arg\\max_{c_i}P(c_i|d)argmaxci​​P(ci​∣d)，又因为 P(d)P(d)P(d) 不变，因此也就是求： arg⁡max⁡ci∏j=1nP(tj∣ci)P(ci)∝arg⁡max⁡ci(∑j=1nlog⁡P(tj∣ci)+log⁡P(ci))\\arg\\max_{c_i}\\prod_{j=1}^{n}P(t_j|c_i)P(c_i) \\\\ \\propto \\arg\\max_{c_i}(\\sum_{j=1}^{n}\\log{P(t_j|c_i)}+\\log{P(c_i)}) argci​max​j=1∏n​P(tj​∣ci​)P(ci​)∝argci​max​(j=1∑n​logP(tj​∣ci​)+logP(ci​)) P(tj∣ci)P(t_j|c_i)P(tj​∣ci​) 用词 tjt_jtj​ 在类别 cic_ici​ 的文档中的占比来估计，P(ci)P(c_i)P(ci​) 用类别 cic_ici​ 的文档在所有文档中比重来估计。并且为了避免个别 P(tj∣ci)=0P(t_j|c_i)=0P(tj​∣ci​)=0 导致错误，对单词频数加1进行平滑： \\hat{P}(t_j|c_i) &amp; = \\frac{N(t=t_j,\\space c=c_i)+1}{\\sum_{t_k \\in V_i} (N(t=t_k,\\space c=c_i)+1)} \\\\ &amp; = \\frac{N(t=t_j,\\space c=c_i)+1}{N(c=c_i)+|V_i|} P^(ci)=N(ci)N\\hat{P}(c_i)=\\frac{N(c_i)}{N} P^(ci​)=NN(ci​)​ 其中 N(t=tj,c=ci)N(t=t_j,c=c_i)N(t=tj​,c=ci​) 为 cic_ici​ 类文章中 tjt_jtj​ 出现的次数， ViV_iVi​ 为出现在所有类型为 cic_ici​ 的文档中的单词集合（不重复），∣Vi∣|V_i|∣Vi​∣ 为不重复单词数。 整体框架 Job1：统计N(c=ci)N(c=c_i)N(c=ci​) 输入训练集（分好类的文档，不同类别的文档在不同的目录中，目录名即为类别名） Mapper&lt;Text, Writable, Text, Writable&gt; 使用自定义的InputFormat，只读取文件所在目录名而不读取内容，并且规定split不会切分文件，防止统计冗余 k1=k2：继承InputFormat的输出键值对，类别名=目录名 v1=v2：1 Reducer&lt;Text, List&lt;Writable&gt; 输出 &lt;类别, 总数&gt; Job2：统计 N(t=tj,c=ci)N(t=t_j,c=c_i)N(t=tj​,c=ci​) 输入训练集 Mapper&lt;LongWritable, Text, Text, IntWritable&gt; 使用默认的TextInputFormat RecordReader 按行读取（使用TextInputFormat），一行一个单词，同时读取split包含的文件名作为类别，将类别和单词用-拼接成一个Text类型变量作为Key输出 Value 输出取 1 即可 Reducer&lt; Text, List&lt;IntWritable&gt; &gt; 输出&lt; 类别-单词, 总数 &gt; Job3: 统计∣Vi∣|V_i|∣Vi​∣ 输入job2的output Mapper&lt;Text, IntWritable&gt; RecordReader 读入每一行，Map成&lt;类别，个数&gt; Reducer 输入&lt;类别, list{个数}&gt;，输出&lt;类别, 个数求和&gt; Job3：测试 输入测试集（待分类的文档） 输出文档类别 评估分类效果 环境准备 安装 Hadoop 官网给的都是基于 Linux 系统构建的，如果要在 Windows 系统上使用，需要补全 bin 中的winutils.exe，hadoop.dll等文件 或者下载源码，按照说明自己在 Windows 上构建 需要指定相应版本的 JDK （一般都是 Java 8） 正确设置环境变量 %HADOOP_HOME% 使用 Cygwin 环境执行 Hadoop 命令会产生路径问题，导致无法正确加载类 启用 Hadoop 环境 注意启用 SSH Server 服务 1PowerShell&gt; net start sshd 运行相应的启动脚本以启动 Hadoop 相应服务：$ hadoop-3.3.5\\sbin\\start-xxx.cmd 例如启动 hdfs 则执行 sbin\\start-dfs.cmd 注意使用管理员权限运行 Shell Win 下使用 hdfs dfs 命令行的 -put 和 -get 命令时，指定本地路径时不能使用相对路径 开启dfs后无法写入：离开NameNode安全模式 hdfs dfsadmin -safemode leave 数据准备 选择NBCorpus\\Country\\AUSTR、NBCorpus\\Country\\BRAZ和BCorpus\\Country\\CANA三个目录中的文件作为训练数据，分类的class为AUSTER和CANA 编写python脚本，按照8:2的比例划分训练集和测试集，并存入hdfs 类别 训练集数目 测试集数目 AUSTR 244 61 BRAZ 160 40 CANA 211 52 程序编写 主要编写两个 Java 文件，一个是 MapReduce 程序 NaiveBayes.java，实现朴素贝叶斯分类器算法。另一个是本地控制台程序 Predictor.java ，根据测试集预测并输出评估指标。 NaiveBayes.java 实现三个 job，输入分好词的文件（训练集），以文本形式将统计结果输出到三个文件夹中。 Predictor.java 根据测试集文件夹内容对每个文件进行预测，产生混淆矩阵，并计算每个类别对应的 Precision、Recall和F1值，最后还会输出指标平均值。 编译运行 执行以下命令编译 NaiveBayes.java 文件（或者在IDEA中编译），获得一系列字节码文件 NaiveBayes*.class 1$ hadoop com.sun.tools.javac.Main -Xlint:deprecation -encoding UTF-8 NaiveBayes.java 打包 jar 并部署到 hadoop 运行 12$ jar cf nb.jar NaiveBayes*.class$ hadoop jar D:\\Workspace\\MapReduce-Bayes\\src\\main\\java\\nb.jar NaiveBayes /bayes/dataset/train /bayes/output/job1 /bayes/output/job2 AUSTR CANA BRAZ 将输出结果复制到本地 123$ hdfs dfs -get /bayes/output/job1/part-r-00000 D:\\Workspace\\MapReduce-Bayes\\model\\job1$ hdfs dfs -get /bayes/output/job2/part-r-00000 D:\\Workspace\\MapReduce-Bayes\\model\\job2$ hdfs dfs -get /bayes/output/job3/part-r-00000 D:\\Workspace\\MapReduce-Bayes\\model\\job3 三个 job 的输出结果预览如下所示 job1123AUSTR 244BRAZ 160CANA 210 job21234567891011121314151617181920...AUSTR-0.020 2AUSTR-0.02goodman 1AUSTR-0.02macraes 1AUSTR-0.03 3AUSTR-0.0310yrbond 1... (省略)BRAZ-ymos 1BRAZ-york 7BRAZ-zagallo 1BRAZ-zamorano 2BRAZ-zero 1BRAZ-zinc 3CANA-0 26CANA-0-8 1CANA-0.0 2CANA-0.02 1CANA-0.03 3CANA-0.043 1... job3123AUSTR 50361BRAZ 20346CANA 34270 IDEA下编译运行 Predictor.java 查看预测结果 实验结果 预测评估 Predictor 的控制台输出如下，从上到下依次是混淆矩阵、各个类别的 Precision、Recall和F1分数，最后是均值。","link":"/posts/77f0d3e3/"},{"title":"杂项&#x2F;Ideas","text":"Williams’s Fantastic Ideas Github 有一个叫做 app ideas 的仓库有很多好的项目 根据图片定位到视频中的某一帧","link":"/posts/853a41fd/"},{"title":"杂项&#x2F;读书笔记约法三章","text":"Note 读书笔记约法三章 “无他，唯手熟尔” 读书不做笔记，不常常温习约等于没学，重视笔记，舍得投入时间。 一曰： 读完一章后提炼出主要知识点，并结合 自己的理解 进行记录。 二曰： 读的过程中发现每一章节的联系（理解作者这样编排内容的深意），及时对之前的笔记进行补充说明甚至重新理解。 三曰： 进行二次阅读甚至多次阅读，修改理解不到位的、遗漏的知识点。 四曰： 实际运用书中内容的时候将遇到的问题、积累的经验写在笔记中。","link":"/posts/e8be4afa/"},{"title":"技术&#x2F;语言&#x2F;LatexTikz","text":"Latex 注意事项: \\begin{tikzpicture} 环境下每一行命令结尾都要加分号; \\node, \\coordinate, \\draw 语法参考：https://zhuanlan.zhihu.com/p/84943429 \\node 描点, \\coordinate 拟点, \\draw 画线, \\fill 填充 参考网站: 路径与坐标：https://www.latexstudio.net/archives/51602.html node 控制：https://www.latexstudio.net/archives/51617.html 线条控制: https://www.latexstudio.net/archives/51622.html 示例代码: 12\\node at (A)[circle,fill,inner sep=1pt]{};% 点名 属性","link":"/posts/9b17222d/"},{"title":"技术&#x2F;语言&#x2F;Java&amp;Kotlin语法对照","text":"Java Kotlin 函数式 API Java 123456789101112//传入接口类型的实例（或继承了接口的匿名类）/* public interface Runnable { void Run(); } */new Thread(new Runnable() { @Override public void run() { //执行逻辑 }}).start() Kotlin 1234//传入Lambda表达式（单抽象的接口类型也可简化为Lambda表达式后传入）Thread { //执行逻辑}.start() 访问控制 修饰符 Java Kotlin pubilc 所有类可见 所有类可见（默认修饰符） private 当前类可见 当前类可见 protected 当前类，子类，同意包路径下的类可见 当前类，子类可见 default 同一包目录下的类可见（默认修饰符） 无 internal 无 同一模块下的类可见 Class 对象引用 语言 实例的Class对象 类的Class对象 Kotlin javaclass 类名::class.java Java (this).getclass() 类名.class","link":"/posts/7a368ad4/"},{"title":"技术&#x2F;语言&#x2F;JavaLearning","text":"Java content: 对象与类，基本数据类型 int a, b; 则“a=b”表达式为int类型，不会自动转化为boolean类型 Java 的匿名内部类 Java12345678910111213//定义语法new 父类构造器（实参列表) | 实现接口() //必须继承一个父类或接口{ //匿名内部类的类体部分}/** * 规范： * 匿名类的声明是由java编译器自动派生自一个类实例创建表达式。 * 匿名类永远不能是抽象的。 * 匿名类总是隐式的final。 * 匿名类总是一个内部类；并且不能是static的。 */ 注意： 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。 匿名内部类中是不能定义构造函数的。 匿名内部类中不能存在任何的静态成员变量和静态方法。 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。 内部类的class文件命名是：主类＋$＋内部类名 匿名类的class文件命名是：主类＋$＋(1,2,3…) class 对象 获取方式：有三种获得Class对象的方式： Class.forName(“类的全限定名”) 实例对象.getClass() 类名.class （类字面常量） 每个类的运行时的类型信息就是用Class对象表示的","link":"/posts/6374ed46/"},{"title":"技术&#x2F;语言&#x2F;Kotlin 学习笔记","text":"Kotlin Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。 $a 和 ${a.func()}我是真没话说。 完善的NULL检查机制 “!!, ?, ?:”（当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。方法是： “Type后 + ？”） 玩转for循环：可以方便的指定遍历的步长，范围。（ …, step, downTo, in, until) Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。 支持二进制字面量，数值类型混入下划线增加语义性。 有些时候较小类型不会隐式转换成较大类型，需要手动调用 .toXXX() 来进行显示的类型转换。 和 golang 一样少了分号（这就是语法糖吗i了i了 if-else 语句与when语句等可以视为 表达式（可赋值 when 与 -&gt; 符号构成强大的分支控制。 完全抛弃基本数据类型改用对象数据类型“。 “fun xxx() = xxx” 这个语法糖结合 if else, when 等特性可以打出漂亮的组合拳。 class 继承的时候对继承的父类后面一般要加括号（因为 java 继承中必调用父类构造函数）且此构造函数必调用著构造函数。 Java 与 Kotlin 访问修饰符对照表 修饰符 Java Kotlin pubilc 所有类可见 所有类可见（默认修饰符） private 当前类可见 当前类可见 protected 当前类，子类，同意包路径下的类可见 当前类，子类可见 default 同一包目录下的类可见（默认修饰符） 无 internal 无 同一模块下的类可见 语法糖: 原生支持数据类、单例类 （自动完成 toString(), hashCode(), equals() 等方法） 数据类对比 Java-example12345678910111213141516171819202122232425262728public class Cellphone { String brand; double price; public Cellphone(String brand, double price) { this.brand = brand; this.price = price; } @Override public boolean equals(Object obj) { if (obj instanceof Cellphone) { Cellphone other = (Cellphone) obj; return other.brand.equals(brand) &amp;&amp; other.price == price; } return false; } @Override public int hashCode() { return brand.hashCode() + (int) price; } @Override public String toString() { return \"Cellphone(brand=\" + brand + \", price=\" + price + \")\"; }} Kotlin-example1data class Cellphone(val brand: String, val price: Double) //加一个data即可 单例类对比 Java-example12345678910111213141516public class Singleton { private static Singleton instance; private Singleton() {} public synchronized static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } public void singletonTest() { System.out.println(\"singletonTest is called.\"); }} Kotlin-example12345object Singleton { //只需要用object代替class即可 fun singletonTest() { println(\"singletonTest is called.\") } //这里相当于一个静态方法} Kotlin class 类 语言 实例的Class对象 类的Class对象 Kotlin javaclass 类名::class.java Java (this).getclass() 类名.class Kotlin 标准函数 一系列定义于 Standard.kt 里的函数 参照表 函数 特点 代码段 let() 调用let的对象作为Lamda的参数，返回最后一行 obj.let {(obj2 -&gt;) //obj2是obj} with() 传入对象作为Lambda的上下文，返回最后一行 with(obj) {//obj上下文} run() 调用run的对象作为Lamda的上下文，返回最后一行 obj.run {//obj上下文} apply() 调用apply的对象作为Lamda的上下文，返回原对象 obj.apply {//obj上下文} Kotlin “静态方法调用” 单例类 objetc {} 伴生类 companion object {} 顶层方法 fun xxx()，可以被任意Kotlin代码直接调用，文件名作为类还可以用于java静态方法调用 @JvmStatic 注释，只能加注在单例类方法或伴生类方法上，使其编译成java静态方法","link":"/posts/ec3dabc7/"},{"title":"技术&#x2F;笔记&#x2F;离散数学笔记","text":"Math 课程笔记 计数技术基础 乘法原理与笛卡尔积的基数 |A1 ⨉ A2 ⨉ ∙∙∙ ⨉ Am |= |A1| ∙ |A2| ∙ ∙∙∙ ∙ |Am| 容斥原理 有根树图 鸽巢原理 推论：一个从m个元素到n个元素（m&gt;n)的函数不可能是单射。 广义鸽巢原理 如果N 个物体放置到k个盒子中，那么至少 有一个盒子装有不少于⌈N/k⌉个物体。 关键词：至少，分配（/填色/分类） 要用上鸽巢原理就要灵活转换问题 可用结论： 任何一个正整数都给可以分解为一个2的次幂×一个奇数 排列组合 乘法原理，加法原理，组合，排列 二项式系数与组合分析法 组合分析法证明 允许重复的n元素的r排列 nrn^rnr 允许重复的n元素的r组合 Cn+r−1rC_{n+r-1}^rCn+r−1r​ 思想：隔板选位，不定方程求解 可分辨与不可分辨的分配问题 将n个可以辨别的物体（或者说n个不同的物体）放入到k 个可以辨别的盒子里，使得第i个盒子有ni个物体，有：n!/(n1!n2! ∙∙∙nk!) 种方法，多的可以认为全都放到第k+1个盒子里！ proof：分类组合 不可分辨的物体放入可分辨的盒子里：不定方程问题 Cn+r−1rC_{n+r-1}^rCn+r−1r​ 递推关系 线性齐次递推关系通解形式 an=∑iCinkrna_n=\\sum^i C_in^kr^nan​=∑iCi​nkrn CiC^iCi为待定常系数，r为特征根，k依据重根数决定（例如二重根r1,r2r_1, r_2r1​,r2​，对应项C1rn,C2rnC_1r^n, C_2r^nC1​rn,C2​rn） 线性非齐次递推关系特解形式 如果f(n)为n次多项式，则特解一般也是n次多项式 F(n)为指数函数βn\\beta^nβn，若β\\betaβ不是特征根，则有特解为 H∗(n)=PβnH^*(n) = P\\beta^nH∗(n)=Pβn 其中P为待定常数. 若β是e重特征根，则特解为PneβnPn^e\\beta^nPneβn 生成函数 表示序列的一种有效方法是生成函数，它把序列的项作为 一个形式幂级数中变量x幂的系数。这样的生成函数可以 用来求解许多类型的计数问题，诸如 在各种限制下选取或分配不同种类的物体的方式数； 用不同面额钱币构成某个数额的钱的问题； 求解某些带限制条件的不定方程的问题等等。 整数分解问题 用生成函数求解特殊的递推关系 值得注意的是：利用生成函数解决问题关注的是幂级数的形式，幂级数是否收敛不重要。利用生成函数的性质（比如展开成幂级数，幂级数求导与积分）可以方便地用来求解计数问题。 生成函数分析法 常用函数的幂级数展开式 广义二项式 常用结论 G(n)=1(1−x)n=∑r=0∞C(n+r−1,r)xrG(n)=\\frac{1}{(1-x)^n}=\\sum_{r=0}^∞C(n+r-1, r)x^rG(n)=(1−x)n1​=∑r=0∞​C(n+r−1,r)xr 生成函数求解不定方程解的个数 应用 转化为不定方程解的个数求解问题 容斥原理 第二形式：N(P′1P′2 . . . P′n) = N − |A1 ∪A2 ∪ · · · ∪An| AiA_iAi​标识包含属性PiP_iPi​的集合 错位排列 模余运算 同余运算性质 if a ≡ b (mod m) &amp; c ≡ d (mod m) then a+c ≡ (b+d) (mod m) &amp; ac ≡ bd (mod m) (m为正整数) a≡b(mod m)⇒ca≡cb(mod m) (c∈Z)a \\equiv b (mod\\space m) \\Rightarrow ca \\equiv cb (mod\\space m)\\space (c \\in Z)a≡b(mod m)⇒ca≡cb(mod m) (c∈Z) ca≡cb(mod m) ⇒a≡b(mod m) (gcd(c,m)=1)ca \\equiv cb (\\text{mod}\\space m)\\space \\Rightarrow a \\equiv b (\\text{mod}\\space m)\\space (gcd(c,m) = 1)ca≡cb(mod m) ⇒a≡b(mod m) (gcd(c,m)=1) 和、积的模 (a + b) mod m = ((a mod m) + (b mod m)) mod m ab modm = ((a modm) (b mod m)) mod m (m为正整数) 最大公因子 gcd(a, b)是a，b的线性组合 求法： 素数分解 辗转相除法 同余方程 解线性同余方程 ax ≡ b (mod m) 模逆 aˉa=1 (m)\\bar aa = 1\\space (m)aˉa=1 (m) 模逆存在唯一性定理：gcd(a,m)=1, m&gt;1gcd(a, m) = 1,\\space m &gt; 1gcd(a,m)=1, m&gt;1则a关于模m的模逆存在且正唯一 求模逆 a, m 辗转相除，倒回去写成1 = sa + km的形式，s即为模逆 可求模逆的方程解法 求模逆 两边同乘模逆消掉系数a 得出结论 欧拉函数 1到n范围内与n互素的数的集合叫做欧拉函数单元的集合（units），其数量为欧拉函数Φ(n) 性质 p, q为素数 Φ(n)(p)=p−1\\Phi(n)(p) = p − 1Φ(n)(p)=p−1 Φ(pq)=pq−(p+q−1)=(p−1)(q−1)\\Phi(pq) = pq − (p + q − 1) = (p − 1)(q − 1)Φ(pq)=pq−(p+q−1)=(p−1)(q−1) 欧拉定理 欧拉定理: aΦ(n)≡1 (mod n)a^{\\Phi(n)} \\equiv 1 \\space (\\text{mod} \\space n)aΦ(n)≡1 (mod n) (a是n的一个unit) Fermat Little Theorem： ap−1=1(mod p)a^{p-1}=1 (mod\\space p)ap−1=1(mod p) (p是一个素数 &amp;&amp; p不能整除a) ap≡a(mod p)a^p\\equiv a(\\text{mod}\\space p)ap≡a(mod p) (p是一个素数 &amp;&amp; a为任意整数) RSA加密解密 素数p，q，有ϕ(pq)=(p−1)(q−1)\\phi(pq)=(p-1)(q-1)ϕ(pq)=(p−1)(q−1)，令M=pqM=pqM=pq，ed≡1(mod M)≡1(mod (p−1)(q−1))ed\\equiv 1(mod \\space M)\\equiv 1(mod \\space(p-1)(q-1))ed≡1(mod M)≡1(mod (p−1)(q−1)) 记明文为P，密文为C 接收方选择好p，q，e然后计算好M，d发送出去 发送方接受(M, d)并发送密文C≡Pd (mod M)C\\equiv P^d\\space (\\text{mod}\\space M)C≡Pd (mod M) 接收方解密P≡Ce (mod M)P\\equiv C^e\\space (\\text{mod}\\space M)P≡Ce (mod M)","link":"/posts/b09d8377/"},{"title":"技术&#x2F;指南&#x2F;小技巧手册","text":"Note 每天一个避坑小技巧 解决网站元素（例如图片）加载不出来的方法 浏览器下审查该元素的URL地址，然后在搜索他的域名对应的地址（https://tools.ipip.net/domain.php） 将域名解析 “xxx.xxx.xxx.xxx 域名” 加入到hosts文件中（一般在 %SystemRoot%\\system32\\drivers\\etc\\ 目录下） cmd 下 ipconfig \\flushdns 刷新试试 刷新浏览器查看效果 SSR 解决端口占用问题： 法一：在 SSR 选项设置里改变端口 法二：taskkill /pid xxx -f","link":"/posts/fac7f463/"},{"title":"技术&#x2F;指南&#x2F;Ubuntu &amp; Windows 10 双系统安装指南","text":"技术 系统 Linux Ubuntu &amp; Windows 10 双系统安装指南 综述 Linux 发行版选择 Ubuntu 镜像下载 Rufus 软件烧录镜像文件到U盘 Bios 设置与 Controller Mode 修改 U盘启动安装 Ubuntu 发行版选择 RedHat 系 RedHat 商业 CentOS 稳定、国内用的多 Debian 系 Debian 开源 Ubuntu 图形界面好看、大众、易用 其他 Arch 极客至爱，萌新杀手 镜像下载 概念解读 LTS - 长期支持版本：长期支持（LTS）版本通常与应用程序或操作系统有关，你会在较长的时间内获得安全、维护和（有时有）功能的更新。 区别 Ubuntu Server 和 Ubuntu Desktop 版本 烧录镜像 UltraISO 和 Rufus 都可以将 iso 文件烧录到U盘中 安装系统 较新的Windows10支持shift+点击重启-》高级选项-》固件设置 的方式进入BIOS设置 选择启动设备时发现没有Removable USB Device选项，只有一个Linpus Lite Device 选项，查证发现该选项对应的是我的刻录了Ubuntu的闪存U盘 安装双系统时在Ubuntu安装界面一定要注意给系统引导一个分区：对EFI方式的电脑要分出一个efi格式的分区作为Ubuntu系统的引导（Windows系统的引导也是这个格式，叫Windows Boot Manager），而传统BIOS方式的电脑只需要分出一个ext4的分区/boot。 知识点 固件 完成计算机加电后初始化等一系列工作的硬件设备 磁盘 磁盘基础知识、分区知识（包括分区格式MBR与GPT的区别以及对应的系统引导机制EFI/UEFI与传统Bios模式）磁盘知识_Forskamse’s Blog-CSDN博客","link":"/posts/5258147c/"},{"title":"技术&#x2F;指南&#x2F;IDE&amp;Editor Shortcuts Query","text":"Tools 各大 IDE &amp; Editor 快捷键对照表 操作 IntelliJ IDEA Visual Studio Code Visual Studio 编辑 Editing 格式化代码 Format Code Ctrl+Shift+L Shift+Alt+F 删除行 Delete Line Ctrl+Y Ctrl+Shift+K 选中行 Select Line Ctrl+L 复制行 Copy Line Ctrl+C Ctrl+C 剪切行 Cut Line Ctrl+X Ctrl+X 重复行 Duplicate Line Ctrl+D Alt+Shift+Up/Down 移动行 Move Line Alt+Shift+Up/Down Alt+Up/Down 换行 New Line Shift+Enter Shift+Enter 插入上行 Insert Line Above Ctrl+Alt+Enter Ctrl+Shift+Enter 注释 Comment Ctrl+/ Ctrl+/ 块注释 Block Comment Ctrl+Shift+/ Ctrl+Shift+/ 选择块 Block Selection Ctrl+W Ctrl+Shift+W Alt+Shift+Right/Left 选择相同内容 Alt+J Ctrl+D 优化导包 Optimize Imports Ctrl+Alt+O 代码提示 Code Assist Ctrl+Space Ctrl+Shift+Space 代码补全 Code Completion Ctrl+Shift+Enter 快速修复 Quick Fix Alt+Enter Quick Access Double Shift 参数信息 Parameter Info Ctrl+P 查看API文档 Quick Document Ctrl+Q 新建文件 New File Ctrl+N 激活编辑器 Active Editor Esc 全部小写 全部大写 导航 Navigation 上/下一个Tab Alt+Left/Right Ctrl+PgUp/PgDn 上/下一个 Ctrl+Alt+Left/Right 上一处修改的地方 Ctrl+Shift+Backspace 跳转到行 Go To Line Ctrl+G Ctrl+G 大纲/结构 Outline/Structure Ctrl+F12 查看类层级 Type Hierarchy 查看最近文件 Recent File Ctrl+E 跳到文件 Go To File 切换视图 Switch View 重构 Refator 重命名 Rename Shift+F6 提取变量 Extract Variable 提取方法 Extract Method 搜索 Find 查找 Find Ctrl+F Ctrl+L Ctrl+F 查找下一个 查找上一个 全局搜索","link":"/posts/fde8aecf/"},{"title":"技术&#x2F;指南&#x2F;Hexo icarus 博客维护","text":"hexo 基本指令 基本指令123456789/*npm指令*/npm install/uninstall xxx//执行package.json中定义的脚本npm run server/*hexo指令*/hexo cl &amp;&amp; hexo g &amp;&amp; hexo s //清理，生成，本地服务器hexo d //部署hexagon -l //查看插件 更多 Hexo 指令 传送门 Front-matter 参数 描述 默认值 layout 布局 title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） excerpt 摘要 widget icarus 主题空间 标签插件 Embed 增强了 markdown 的功能的一系列插件 info: embed 语法不要包裹在反引号中，且冒号后面不要空格！！ 官方文档 官方插件文档 其他插件 探宝方法：hexo.io 搜索 embed 自己做：&lt;embed&gt; hexo-github-card hexo-pdf hexo-tag-bilibili hexo-tag-douban hexo-tag-bootstrap 插件 Components textcolor - Convey meaning through color with a handful of emphasis utility classes. button - Inserts a button with target links, text and specified color. ** text label - Inserts a label with text and specified color. pill - Inserts a label with text and specified color. ** text badge - Inserts a badge with text. alert - Inserts alert messages with text and specified color. card - Add a card control ** carddeck - use with cards to combine multiples ** cardgroup - similar to carddeck jumbo - jumbotron carousel - carousel tag - each img within will create a new “slide” row - add a grid row col - add a column within a grid row 使用示例 ！🐱‍🏍传送门🐱‍🏍 举亿个栗子 渲染效果因css而异 badge text alert 块级 属性：waring danger success info Best check yo self, you’re not looking too good. Change a few things up and try submitting again. You successfully read this important alert message. This alert needs your attention, but it’s not super important. textcolor （暂无css渲染） Fusce dapibus, tellus ac cursus commodo, tortor mauris nibh. Nullam id dolor id nibh ultricies vehicula ut id elit. Duis mollis, est non commodo luctus, nisi erat porttitor ligula. Maecenas sed diam eget risus varius blandit sit amet non magna. Etiam porta sem malesuada magna mollis euismod. Donec ullamcorper nulla non metus auctor fringilla. 行内label 支持属性 default warning success danger primary info default warinng success danger primary info 行内btn 支持属性 primary success warning danger info btn btn btn btn btn btn 插入HTML来增强阅读体验 Bulma 是一个CSS框架。查看Bulma文档。 CSS 框架不包含js，涉及点击事件需要自行处理！ Note 不用js的情况下适合的组件有：button，dropdown，message Click me Overview Modifiers Grid Form Elements Components Layout More Hover me You can insert any type of content within the dropdown menu. ## 博客备份迁移","link":"/posts/6e7bdc/"},{"title":"技术&#x2F;开发&#x2F;AndroidLearning","text":"Android Android Studio 入坑笔记 Android Studio 自动创建 resource id 失败 重启 AS。 Sync with file system 同步一下？ 查看 R.java 中的 id 。Project 下依次打开app–&gt;build–&gt;generated–&gt;source–&gt;r–&gt;debug，在debug中的两个选项的子文件中分别有有一个R文件，既我们要找的R.java文件。（或者直接shift+shift查找R.java","link":"/posts/fae5c3cd/"},{"title":"技术&#x2F;指南&#x2F;CMD 指令备忘","text":"cmd CMD 指令备忘 Process 类 tasklist 列出所有进程 taskkill /pid xxx -f 杀死指定id process","link":"/posts/369ceeb5/"},{"title":"技术&#x2F;工具&#x2F;IDEA 学习笔记","text":"IDEA基础功能概览： shortcut(edit, 代码片段, 功能), 版本控制(VCS: git, github, local history) Debug, javadoc generator, database, web deployment project&amp;module 等概念, 模板, 项目结构查询管理 Tips 代码段：main sout标准输出 soutv输出变量，soutm输出方法名，soutp输出命令行参数 变量名.sout输出变量 iter增强型for循环 引用名.for 迭代指定引用类型 实例名.fori顺序遍历 xxx.forr倒序遍历 ifn --“if xxx is null”, inn --“if not null” xxx.nn, xxx.ifn JavaLea 条件断点 --右键断点处 ctrl+u 查看表达式的值 Tools javadoc generator: Local: zh_CN; Other command line args: encoding UTF-8 -charset UTF-8 IDE 常用快捷键对照表（原始来源: https://www.jianshu.com/p/6267a7d76018 ) 操作 eclipse IDEA Visual Studio Code Sublime 编辑 Editing 格式化代码 Format Code Ctrl+Shift+F Ctrl+Shift+L Shift+Alt+F 无 删除行 Delete Line Ctrl+D Ctrl+Y Ctrl+Shift+K Ctrl+Shift+K 复制行 Copy Line Ctrl+C Ctrl+C Ctrl+C 剪切行 Cut Line Ctrl+X Ctrl+X Ctrl+X 重复行 Duplicate Line Ctrl+Shift+Up/Down Ctrl+D Alt+Shift+Up/Down Ctrl+Shift+D 移动行 Move Line Alt+Up/Down Alt+Shift+Up/Down Alt+Up/Down Ctrl+Shift+Up/Down 换行 New Line Shift+Enter Shift+Enter Shift+Enter Ctrl+Enter 插入上行 Insert Line Above Ctrl+Shift+Enter Ctrl+Alt+Enter Ctrl+Shift+Enter Ctrl+Shift+Enter 注释 Comment Ctrl+/ Ctrl+/ Ctrl+/ Ctrl+/ 块注释 Block Comment Ctrl+Shift+/ Ctrl+Shift+\\ Ctrl+Shift+/ Ctrl+Shift+/ 选择块 Block Selection Alt+Shift+Up/Down Ctrl+W Ctrl+Shift+W Alt+Shift+Right/Left 优化导包 Optimize Imports Ctrl+Shift+O Ctrl+Alt+O 代码提示 Code Assist Alt+/ Ctrl+Space Ctrl+Shift+Space 代码补全 Code Completion Ctrl+Alt+/比较low Ctrl+Shift+Enter 快速修复 Quick Fix Ctrl+1 Alt+Enter Quick Access Ctrl+3 Double Shift 参数信息 Parameter Info Alt+Shift+/还不如 Alt+/ Ctrl+P 查看API文档 Quick Document Ctrl+Q 新建文件 New File Alt+Shift+N Ctrl+N 激活编辑器 Active Editor F12 Esc 全部小写 Ctrl+Shift+Y 全部大写 Ctrl+Shift+X 导航 Navigation 上/下一个Tab Ctrl+PgUp/PgDn Alt+Left/Right Ctrl+PgUp/PgDn 上/下一个 Alt+Left/Right Ctrl+Alt+Left/Right 上一处修改的地方 Ctrl+Q Ctrl+Shift+Backspace 跳转到行 Go To Line Ctrl+L Ctrl+G 大纲/结构 Outline/Structure Ctrl+O Ctrl+F12 查看类层级 Type Hierarchy Ctrl+T 查看最近文件 Recent File Ctrl+E Ctrl+F6 Ctrl+E 跳到文件 Go To File Ctrl+Shift+N 切换视图 Switch View Ctrl+F7 重构 Refator 重命名 Rename Alt+Shift+R Shift+F6 提取变量 Extract Variable Alt+Shift+L 提取方法 Extract Method Alt+Shift+M 搜索 Find 查找下一个 Ctrl+K 查找上一个 Ctrl+Shfit+K 全局搜索 Ctrl+H","link":"/posts/5a1e79ff/"},{"title":"技术&#x2F;语言&#x2F;Golang 避坑手册","text":"Golang &quot;{&quot;的位置要注意 分号无 多变量声明： //类型相同多个变量, 非全局变量 var vname1, vname2, vname3 type vname1, vname2, vname3 = v1, v2, v3 var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断 vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误 12345// 这种因式分解关键字的写法一般用于声明全局变量var ( vname1 v_type1 vname2 v_type2) 默认值 并行特性：多个返回值，并行赋值 常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过： a = a++ // 这是不允许的，会出现变异错误 syntax error: unexpected ++ at end of statement ! Go 的自增，自减只能作为表达式使用，而不能用于赋值语句。 for each range loop !!! 函数闭包（同一个被赋予闭包函数的函数每次调用都会将匿名函数内的局部变量记忆下来） 12345678910111213141516package mainimport \"fmt\"func main() { add_func := add(1,2) fmt.Println(add_func(1,1)) fmt.Println(add_func(0,0)) fmt.Println(add_func(2,2))} // 闭包使用方法func add(x1, x2 int) func(x3 int,x4 int)(int,int,int) { i := 0 return func(x3 int,x4 int) (int,int,int){ i++ return i,x1+x2,x3+x4 }} := cannot be used globally!!! 全局变量和局部变量都有默认值 结构体与数组的匿名 append()必须要用它的返回值（原因很简单，其参数列表用的是值传递而不是指针传递） map必须要初始化（用make（）或者声明的时候直接赋值），否则只是个nil，无法对其进行赋值！！！？？ !!!GO没有隐式类型转换！！！需要灵活使用显示类型转换！ 将一个结构体赋值给一个接口变量可以想象成该接口成为了一个指向该结构体的“指针” 通道chan类型是“值相关”的，相同chan值描述同一个通道，chan用close（）关闭，）有点像file descriptor？ 两个并发线程时间前后关系不确定，同一个程序可能有不同结果 close一个chan后还能接收，不可发送","link":"/posts/c737d2b3/"},{"title":"杂项&#x2F;Hexo&#39;s tag","text":"Hexo Hexo 的插件扩展调试页面 classDiagram class NotificationManager { +notify() +createNotificationChannel() } class NotificationChannel class NotificationCompat { +Builder() } NotificationCompat NotificationChannel: 创建、管理 NotificationManager --> Notification: 发送 Notification --* NotificationChannel: 对应","link":"/posts/827933de/"},{"title":"技术&#x2F;语言&#x2F;C指针扫盲","text":"C/C++ 首先看看函数指针，函数名，以及它们分别与*和&amp;结合后的值 程序清单 12345678910111213141516171819#include&lt;stdio.h&gt;void func(void){puts(\"成功调用\");};int main(){ void(*p_func)(void)=func; puts(\"func是函数名，p_func是指向该函数的指针，那么有:\"); printf(\"func=%p\\n*func=%p\\n&amp;func=%p\\ \\np_func=%p\\n*p_func=%p\\ \\n&amp;p_func=%p\",func,*func,&amp;func,p_func,\\ *p_func,&amp;p_func); //puts(\"\\n接着我们尝试用上述变量调用函数:\"); //func(); //(*func)(); //(&amp;func)(); //(p_func)(); //(*p_func)(); return 0;} 执行结果 1234567func是函数名，p_func是指向该函数的指针，那么有:func=004015C0*func=004015C0&amp;func=004015C0p_func=004015C0*p_func=004015C0&amp;p_func=0061FECC 可见func,*func,&amp;func,p_func,*p_func代表的值都是func()函数的地址 （ &amp;p_func是指针的地址 ） 再来看看将它们分别作为函数名的结果 程序清单 12345678910111213141516171819#include&lt;stdio.h&gt;void func(void){puts(\"成功调用\");};int main(){ void(*p_func)(void)=func; puts(\"func是函数名，p_func是指向该函数的指针，那么有:\"); printf(\"func=%p\\n*func=%p\\n&amp;func=%p\\ \\np_func=%p\\n*p_func=%p\\ \\n&amp;p_func=%p\",func,*func,&amp;func,p_func,\\ *p_func,&amp;p_func); puts(\"\\n接着我们尝试用上述变量调用函数:\"); func(); (*func)(); (&amp;func)(); (p_func)(); (*p_func)(); return 0;} func，p_func，*p_func，*func，&amp;func作函数名 源程序 12345678 puts(\"\\n接着我们尝试用上述变量调用函数:\"); func(); (*func)(); (&amp;func)(); (p_func)(); (*p_func)(); return 0;} 编译运行结果 12345678910111213func是函数名，p_func是指向该函数的指针，那么有:func=004015C0*func=004015C0&amp;func=004015C0p_func=004015C0*p_func=004015C0&amp;p_func=0061FECC接着我们尝试用上述变量调用函数:成功调用成功调用成功调用成功调用成功调用 可见func，p_func，*p_func，*func，&amp;func作函数名均可以实现函数调用","link":"/posts/f1e4bda1/"},{"title":"算法&#x2F;回合制战斗","text":"OI 一小道C语言题带来的乐趣 要用游戏的玩法打败游戏的情景题! 对于以下题目： 某游戏规则中，甲乙双方每个回合的战斗总是有一方胜利，一方失败。游戏规定：失败的一方要把自己的体力值的1/4加给胜利的一方。例如：如果双方体力值当前都是4，则经过一轮战斗后，双方的体力值会变为：5，3。现在已知：双方开始时的体力值甲：1000，乙：2000。假设战斗中，甲乙获胜的概率都是50%，求解：双方经过4个回合的战斗，体力值之差小于1000的理论概率。 用基础模拟算法来解决： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#define all 16//所有可能的结果数目int exchange(double * x,double * y) //x为吸收血量方 { double t; t=(*y)*0.25;(*x)+=t;(*y)-=t; return 0; } int main(){ int js=0; double x=1000,y=2000; //美好的游戏模拟开始了 for(int i=0;i&lt;=1;i++) { double ax=x,ay=y;//存档，防止数据丢失 i?exchange(&amp;x,&amp;y):exchange(&amp;y,&amp;x); //i判断甲（x）是否赢得一回合，并改变血条 for(int i=0;i&lt;=1;i++) { double bx=x,by=y; i?exchange(&amp;x,&amp;y):exchange(&amp;y,&amp;x); for(int i=0;i&lt;=1;i++) { double cx=x,cy=y; i?exchange(&amp;x,&amp;y):exchange(&amp;y,&amp;x); for(int i=0;i&lt;=1;i++) { double dx=x,dy=y; i?exchange(&amp;x,&amp;y):exchange(&amp;y,&amp;x); if(x-y&lt;1000&amp;&amp;x-y&gt;-1000) js++; x=dx;y=dy; //重新读档，开始下一轮模拟 } x=cx;y=cy;//读档，余同 } x=bx;y=by; } x=ax;y=ay; } printf(\"四回合后体力值差&lt;1000的理论概率:\\n%f\",js*1.0/all); return 0;} 是不是特像打游戏刷关呢?( ^ v ^ )","link":"/posts/aee17ffb/"}],"tags":[{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"图","slug":"图","link":"/tags/%E5%9B%BE/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"NLP","slug":"NLP","link":"/tags/NLP/"},{"name":"Command","slug":"Command","link":"/tags/Command/"},{"name":"踩坑","slug":"踩坑","link":"/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"storage","slug":"storage","link":"/tags/storage/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"工具","slug":"技术/工具","link":"/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"},{"name":"开发","slug":"技术/开发","link":"/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"},{"name":"指南","slug":"技术/指南","link":"/categories/%E6%8A%80%E6%9C%AF/%E6%8C%87%E5%8D%97/"},{"name":"笔记","slug":"技术/笔记","link":"/categories/%E6%8A%80%E6%9C%AF/%E7%AC%94%E8%AE%B0/"},{"name":"语言","slug":"技术/语言","link":"/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/"}]}